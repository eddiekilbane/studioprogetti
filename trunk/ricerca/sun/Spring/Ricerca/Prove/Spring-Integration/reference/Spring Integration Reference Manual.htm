
<!-- saved from url=(0113)http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#overview -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      
   <title>Spring Integration Reference Manual</title><link rel="stylesheet" href="./Spring Integration Reference Manual_files/stylesheet.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"><!--Begin Google Analytics code--><script type="text/javascript">
			var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
			document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		</script><script src="./Spring Integration Reference Manual_files/ga.js" type="text/javascript"></script><script type="text/javascript">
			var pageTracker = _gat._getTracker("UA-2728886-3");
			pageTracker._setDomainName("none");
			pageTracker._setAllowLinker(true);
			pageTracker._trackPageview();
		</script><!--End Google Analytics code--><script src="./Spring Integration Reference Manual_files/jquery-1.4.2.min.js" type="text/javascript"></script><link rel="stylesheet" href="./Spring Integration Reference Manual_files/searchtool.css" type="text/css"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Spring Integration Reference Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Fisher</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Marius</span> <span class="surname">Bogoevici</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Iwein</span> <span class="surname">Fuld</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonas</span> <span class="surname">Partner</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Oleg</span> <span class="surname">Zhurakousky</span></h3></div></div></div><div><div class="mediaobject" align="right"><img src="./Spring Integration Reference Manual_files/logo.png" align="right"></div></div><div><span class="productname">Spring Integration<br></span></div><div><p class="releaseinfo">1.0.3</p></div></div><div><div><div class="legalnotice"><a name="d0e42"></a><p>Â© SpringSource Inc., 2009</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="./Spring Integration Reference Manual_files/Spring Integration Reference Manual.htm">1. Spring Integration Overview</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#overview-background">1.1. Background</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#overview-goalsandprinciples">1.2. Goals and Principles</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#overview-components">1.3. Main Components</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#overview-endpoints">1.4. Message Endpoints</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#message">2. Message Construction</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#message-interface">2.1. The Message Interface</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#message-headers">2.2. Message Headers</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#message-implementations">2.3. Message Implementations</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#message-builder">2.4. The MessageBuilder Helper Class</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel">3. Message Channels</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-interfaces">3.1. The MessageChannel Interface</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-implementations">3.2. Message Channel Implementations</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-interceptors">3.3. Channel Interceptors</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-template">3.4. MessageChannelTemplate</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-configuration">3.5. Configuring Message Channels</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#endpoint">4. Message Endpoints</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#endpoint-handler">4.1. Message Handler</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#endpoint-eventdrivenconsumer">4.2. Event Driven Consumer</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#endpoint-pollingconsumer">4.3. Polling Consumer</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#endpoint-namespace">4.4. Namespace Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#service-activator">5. Service Activator</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#service-activator-introduction">5.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#service-activator-namespace">5.2. The &lt;service-activator/&gt; Element</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-adapter">6. Channel Adapter</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-adapter-namespace-inbound">6.1. The &lt;inbound-channel-adapter&gt; element</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-adapter-namespace-outbound">6.2. The &lt;outbound-channel-adapter/&gt; element</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#router">7. Router</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#router-implementations">7.1. Router Implementations</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#router-namespace">7.2. The &lt;router&gt; element</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#router-annotation">7.3. The @Router Annotation</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#filter">8. Filter</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#filter-introduction">8.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#filter-namespace">8.2. The &lt;filter&gt; Element</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#transformer">9. Transformer</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#transformer-introduction">9.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#transformer-namespace">9.2. The &lt;transformer&gt; Element</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#transformer-annotation">9.3. The @Transformer Annotation</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#splitter">10. Splitter</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#splitter-annotation">10.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#d0e1890">10.2. Programming model</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#d0e1913">10.3. Configuring a Splitter using XML</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#d0e1990">10.4. Configuring a Splitter with Annotations</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggregator">11. Aggregator</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggregator-introduction">11.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggregator-functionality">11.2. Functionality</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggregator-api">11.3. Programming model</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggregator-xml">11.4. Configuring an Aggregator with XML</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggregator-annotations">11.5. Configuring an Aggregator with Annotations</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resequencer">12. Resequencer</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#d0e2431">12.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resequencer-functionality">12.2. Functionality</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#d0e2443">12.3. Configuring a Resequencer with XML</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#delayer">13. Delayer</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#delayer-introduction">13.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#delayer-namespace">13.2. The &lt;delayer&gt; Element</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#chain">14. Message Handler Chain</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#chain-introduction">14.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#chain-namespace">14.2. The &lt;chain&gt; Element</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#bridge">15. Messaging Bridge</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#bridge-introduction">15.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#bridge-namespace">15.2. The &lt;bridge&gt; Element</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#gateway">16. Inbound Messaging Gateways</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#gateway-simple">16.1. SimpleMessagingGateway</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#gateway-proxy">16.2. GatewayProxyFactoryBean</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#files">17. File Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#file-intro">17.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#file-reading">17.2. Reading Files</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#file-writing">17.3. Writing files</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#file-transforming">17.4. File Transformers</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#jms">18. JMS Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#jms-inbound-channel-adapter">18.1. Inbound Channel Adapter</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#jms-message-driven-channel-adapter">18.2. Message-Driven Channel Adapter</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#jms-outbound-channel-adapter">18.3. Outbound Channel Adapter</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#jms-inbound-gateway">18.4. Inbound Gateway</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#jms-outbound-gateway">18.5. Outbound Gateway</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#jms-samples">18.6. JMS Samples</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#ws">19. Web Services Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#webservices-outbound">19.1. Outbound Web Service Gateways</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#webservices-inbound">19.2. Inbound Web Service Gateways</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#webservices-namespace">19.3. Web Service Namespace Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#rmi">20. RMI Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#rmi-intro">20.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#rmi-outbound">20.2. Outbound RMI</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#rmi-inbound">20.3. Inbound RMI</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#rmi-namespace">20.4. RMI namespace support</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#httpinvoker">21. HttpInvoker Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#httpinvoker-intro">21.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#httpinvoker-inbound">21.2. HttpInvoker Inbound Gateway</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#httpinvoker-outbound">21.3. HttpInvoker Outbound Gateway</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#httpinvoker-namespace">21.4. HttpInvoker Namespace Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#http">22. HTTP Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#http-intro">22.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#http-inbound">22.2. Http Inbound Gateway</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#http-outbound">22.3. Http Outbound Gateway</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#http-namespace">22.4. Http Namespace Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#mail">23. Mail Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#mail-outbound">23.1. Mail-Sending Channel Adapter</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#mail-inbound">23.2. Mail-Receiving Channel Adapter</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#mail-namespace">23.3. Mail Namespace Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#stream">24. Stream Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#stream-intro">24.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#stream-reading">24.2. Reading from streams</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#stream-writing">24.3. Writing to streams</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#stream-namespace">24.4. Stream namespace support</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#applicationevent">25. Spring ApplicationEvent Support</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#applicationevent-inbound">25.1. Receiving Spring ApplicationEvents</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#applicationevent-outbound">25.2. Sending Spring ApplicationEvents</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xml">26. Dealing with XML Payloads</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xml-intro">26.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xml-transformation">26.2. Transforming xml payloads</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xml-transformer-namespace">26.3. Namespace support for xml transformers</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xpath-splitting">26.4. Splitting xml messages</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xpath-routing">26.5. Routing xml messages using XPath</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xpath-selector">26.6. Selecting xml messages using XPath</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xpath-namespace-support">26.7. XPath components namespace support</a></span></dt></dl></dd><dt><span class="chapter"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#security">27. Security in Spring Integration</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#security-intro">27.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#securing-channels">27.2. Securing channels</a></span></dt></dl></dd><dt><span class="appendix"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#samples">A. Spring Integration Samples</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#samples-cafe">A.1. The Cafe Sample</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#samples-xml-messaging">A.2. The XML Messaging Sample</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#samples-osgi">A.3. The OSGi Samples</a></span></dt></dl></dd><dt><span class="appendix"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#configuration">B. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#configuration-introduction">B.1. Introduction</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#configuration-namespace">B.2. Namespace Support</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#namespace-taskscheduler">B.3. Configuring the Task Scheduler</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#namespace-errorhandler">B.4. Error Handling</a></span></dt><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#annotations">B.5. Annotation Support</a></span></dt></dl></dd><dt><span class="appendix"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resources">C. Additional Resources</a></span></dt><dd><dl><dt><span class="section"><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resources-home">C.1. Spring Integration Home</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="overview"></a>1.&nbsp;Spring Integration Overview</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-background"></a>1.1&nbsp;Background</h2></div></div></div><p>
      One of the key themes of the Spring Framework is <span class="emphasis"><em>inversion of control</em></span>. In its broadest
      sense, this means that the framework handles responsibilities on behalf of the components that are managed within
      its context. The components themselves are simplified since they are relieved of those responsibilities. For
      example, <span class="emphasis"><em>dependency injection</em></span> relieves the components of the responsibility of locating or
      creating their dependencies. Likewise, <span class="emphasis"><em>aspect-oriented programming</em></span> relieves business
      components of generic cross-cutting concerns by modularizing them into reusable aspects. In each case, the end
      result is a system that is easier to test, understand, maintain, and extend.
    </p><p>
      Furthermore, the Spring framework and portfolio provide a comprehensive programming model for building
      enterprise applications. Developers benefit from the consistency of this model and especially the fact that it is
      based upon well-established best practices such as programming to interfaces and favoring composition over
      inheritance. Spring's simplified abstractions and powerful support libraries boost developer productivity while
      simultaneously increasing the level of testability and portability. 
    </p><p>
      Spring Integration is a new member of the Spring portfolio motivated by these same goals and principles. It
      extends the Spring programming model into the messaging domain and builds upon Spring's existing enterprise
      integration support to provide an even higher level of abstraction. It supports message-driven architectures
      where inversion of control applies to runtime concerns, such as <span class="emphasis"><em>when</em></span> certain business logic
      should execute and <span class="emphasis"><em>where</em></span> the response should be sent. It supports routing and transformation
      of messages so that different transports and different data formats can be integrated without impacting
      testability. In other words, the messaging and integration concerns are handled by the framework, so business
      components are further isolated from the infrastructure and developers are relieved of complex integration
      responsibilities.
    </p><p>
      As an extension of the Spring programming model, Spring Integration provides a wide variety of configuration
      options including annotations, XML with namespace support, XML with generic "bean" elements, and of course direct
      usage of the underlying API. That API is based upon well-defined strategy interfaces and non-invasive, delegating
      adapters. Spring Integration's design is inspired by the recognition of a strong affinity between common patterns
      within Spring and the well-known <a class="ulink" href="http://www.eaipatterns.com/" target="_top">Enterprise Integration Patterns</a>
      as described in the book of the same name by Gregor Hohpe and Bobby Woolf (Addison Wesley, 2004). Developers who
      have read that book should be immediately comfortable with the Spring Integration concepts and terminology.
	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-goalsandprinciples"></a>1.2&nbsp;Goals and Principles</h2></div></div></div><p>Spring Integration is motivated by the following goals:
      </p><div class="itemizedlist"><ul type="disc"><li><p>Provide a simple model for implementing complex enterprise integration solutions.</p></li><li><p>Facilitate asynchronous, message-driven behavior within a Spring-based application.</p></li><li><p>Promote intuitive, incremental adoption for existing Spring users.</p></li></ul></div><p>
    </p><p>Spring Integration is guided by the following principles:
      </p><div class="itemizedlist"><ul type="disc"><li><p>Components should be <span class="emphasis"><em>loosely coupled</em></span> for modularity and testability.</p></li><li><p>The framework should enforce <span class="emphasis"><em>separation of concerns</em></span> between business logic and
          integration logic.</p></li><li><p>Extension points should be abstract in nature but within well-defined boundaries to promote
	      <span class="emphasis"><em>reuse</em></span> and <span class="emphasis"><em>portability</em></span>.</p></li></ul></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-components"></a>1.3&nbsp;Main Components</h2></div></div></div><p>
      From the <span class="emphasis"><em>vertical</em></span> perspective, a layered architecture facilitates separation of concerns,
      and interface-based contracts between layers promote loose coupling. Spring-based applications are typically
      designed this way, and the Spring framework and portfolio provide a strong foundation for following this best
      practice for the full-stack of an enterprise application. Message-driven architectures add a
      <span class="emphasis"><em>horizontal</em></span> perspective, yet these same goals are still relevant. Just as "layered
      architecture" is an extremely generic and abstract paradigm, messaging systems typically follow the similarly
      abstract "pipes-and-filters" model. The "filters" represent any component that is capable of producing and/or
      consuming messages, and the "pipes" transport the messages between filters so that the components themselves
      remain loosely-coupled. It is important to note that these two high-level paradigms are not mutually exclusive.
      The underlying messaging infrastructure that supports the "pipes" should still be encapsulated in a layer whose
      contracts are defined as interfaces. Likewise, the "filters" themselves would typically be managed within a layer
      that is logically above the application's service layer, interacting with those services through interfaces much
      in the same way that a web-tier would.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-components-message"></a>Message</h3></div></div></div><p>
        In Spring Integration, a Message is a generic wrapper for any Java object combined with metadata used by the
        framework while handling that object. It consists of a payload and headers. The payload can be of any type and
        the headers hold commonly required information such as id, timestamp, expiration, and return address. Headers
        are also used for passing values to and from connected transports. For example, when creating a Message from a
        received File, the file name may be stored in a header to be accessed by downstream components. Likewise, if a
        Message's content is ultimately going to be sent by an outbound Mail adapter, the various properties (to, from,
        cc, subject, etc.) may be configured as Message header values by an upstream component. Developers can also
        store any arbitrary key-value pairs in the headers.
        </p><div class="mediaobject" align="center"><img src="./Spring Integration Reference Manual_files/message.png" align="middle"></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-components-channel"></a>Message Channel</h3></div></div></div><p>
        A Message Channel represents the "pipe" of a pipes-and-filters architecture. Producers send Messages to
        a channel, and consumers receive Messages from a channel. The Message Channel therefore decouples the
        messaging components, and also provides a convenient point for interception and monitoring of Messages.
        </p><div class="mediaobject" align="center"><img src="./Spring Integration Reference Manual_files/channel.png" align="middle"></div><p>
        A Message Channel may follow either Point-to-Point or Publish/Subscribe semantics. With a Point-to-Point
        channel, at most one consumer can receive each Message sent to the channel. Publish/Subscribe channels, on the
        other hand, will attempt to broadcast each Message to all of its subscribers. Spring Integration supports
        both of these.
      </p><p>
        Whereas "Point-to-Point" and "Publish/Subscribe" define the two options for <span class="emphasis"><em>how many</em></span>
        consumers will ultimately receive each Message, there is another important consideration: should the channel
        buffer messages? In Spring Integration, <span class="emphasis"><em>Pollable Channels</em></span> are capable of buffering
        Messages within a queue. The advantage of buffering is that it allows for throttling the inbound Messages and
        thereby prevents overloading a consumer. However, as the name suggests, this also adds some complexity, since a
        consumer can only receive the Messages from such a channel if a <span class="emphasis"><em>poller</em></span> is configured. On
        the other hand, a consumer connected to a <span class="emphasis"><em>Subscribable Channel</em></span> is simply Message-driven.
        The variety of channel implementations available in Spring Integration will be discussed in detail in
        <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-implementations" title="3.2Â Message Channel Implementations">Section&nbsp;3.2, âMessage Channel Implementationsâ</a>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-components-endpoint"></a>Message Endpoint</h3></div></div></div><p>
        One of the primary goals of Spring Integration is to simplify the development of enterprise integration
        solutions through <span class="emphasis"><em>inversion of control</em></span>. This means that you should not have to implement
        consumers and producers directly, and you should not even have to build Messages and invoke send or receive
        operations on a Message Channel. Instead, you should be able to focus on your specific domain model with an
        implementation based on plain Objects. Then, by providing declarative configuration, you can "connect"
        your domain-specific code to the messaging infrastructure provided by Spring Integration. The components
        responsible for these connections are Message Endpoints. This does not mean that you will necessarily connect
        your existing application code directly. Any real-world enterprise integration solution will require some
        amount of code focused upon integration concerns such as <span class="emphasis"><em>routing</em></span> and
        <span class="emphasis"><em>transformation</em></span>. The important thing is to achieve separation of concerns between such
        integration logic and business logic. In other words, as with the Model-View-Controller paradigm for web
        applications, the goal should be to provide a thin but dedicated layer that translates inbound requests into
        service layer invocations, and then translates service layer return values into outbound replies. The next
        section will provide an overview of the Message Endpoint types that handle these responsibilities, and in
        upcoming chapters, you will see how Spring Integration's declarative configuration options provide a
        non-invasive way to use each of these.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-endpoints"></a>1.4&nbsp;Message Endpoints</h2></div></div></div><p>
      A Message Endpoint represents the "filter" of a pipes-and-filters architecture. As mentioned above, the
      endpoint's primary role is to connect application code to the messaging framework and to do so in a non-invasive
      manner. In other words, the application code should ideally have no awareness of the Message objects or the
      Message Channels. This is similar to the role of a Controller in the MVC paradigm. Just as a Controller handles
      HTTP requests, the Message Endpoint handles Messages. Just as Controllers are mapped to URL patterns, Message
      Endpoints are mapped to Message Channels. The goal is the same in both cases: isolate application code from the
      infrastructure. These concepts are discussed at length along with all of the patterns that follow in the
      <a class="ulink" href="http://www.eaipatterns.com/" target="_top">Enterprise Integration Patterns</a> book. Here, we provide only a
      high-level description of the main endpoint types supported by Spring Integration and their roles. The chapters
      that follow will elaborate and provide sample code as well as configuration examples.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-endpoints-transformer"></a>Transformer</h3></div></div></div><p>
        A Message Transformer is responsible for converting a Message's content or structure and returning the modified
        Message. Probably the most common type of transformer is one that converts the payload of the Message from one
        format to another (e.g. from XML Document to java.lang.String). Similarly, a transformer may be used to add,
        remove, or modify the Message's header values.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-endpoints-filter"></a>Filter</h3></div></div></div><p>
        A Message Filter determines whether a Message should be passed to an output channel at all. This simply
        requires a boolean test method that may check for a particular payload content type, a property value, the
        presence of a header, etc. If the Message is accepted, it is sent to the output channel, but if not it will be
        dropped (or for a more severe implementation, an Exception could be thrown). Message Filters are often used in
        conjunction with a Publish Subscribe channel, where multiple consumers may receive the same Message and use the
        filter to narrow down the set of Messages to be processed based on some criteria.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          Be careful not to confuse the generic use of "filter" within the Pipes-and-Filters architectural pattern with
          this specific endpoint type that selectively narrows down the Messages flowing between two channels. The
          Pipes-and-Filters concept of "filter" matches more closely with Spring Integration's Message Endpoint: any
          component that can be connected to Message Channel(s) in order to send and/or receive Messages.
        </td></tr></tbody></table></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-endpoints-router"></a>Router</h3></div></div></div><p>
        A Message Router is responsible for deciding what channel or channels should receive the Message next (if any).
        Typically the decision is based upon the Message's content and/or metadata available in the Message Headers.
        A Message Router is often used as a dynamic alternative to a statically configured output channel on
        a Service Activator or other endpoint capable of sending reply Messages. Likewise, a Message Router provides a
        proactive alternative to the reactive Message Filters used by multiple subscribers as described above.
        </p><div class="mediaobject" align="center"><img src="./Spring Integration Reference Manual_files/router.png" align="middle"></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-endpoints-splitter"></a>Splitter</h3></div></div></div><p>
        A Splitter is another type of Message Endpoint whose responsibility is to accept a Message from its input
        channel, split that Message into multiple Messages, and then send each of those to its output channel. This
        is typically used for dividing a "composite" payload object into a group of Messages containing the
        sub-divided payloads.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-endpoints-aggregator"></a>Aggregator</h3></div></div></div><p>
        Basically a mirror-image of the Splitter, the Aggregator is a type of Message Endpoint that receives multiple
        Messages and combines them into a single Message. In fact, Aggregators are often downstream consumers in a
        pipeline that includes a Splitter. Technically, the Aggregator is more complex than a Splitter, because it
        is required to maintain state (the Messages to-be-aggregated), to decide when the complete group of Messages
        is available, and to timeout if necessary. Furthermore, in case of a timeout, the Aggregator needs to know
        whether to send the partial results or to discard them to a separate channel. Spring Integration provides
        a <code class="interfacename">CompletionStrategy</code> as well as configurable settings for timeout, whether
        to send partial results upon timeout, and the discard channel.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-endpoints-service-activator"></a>Service Activator</h3></div></div></div><p>
        A Service Activator is a generic endpoint for connecting a service instance to the messaging system. The
        input Message Channel must be configured, and if the service method to be invoked is capable of returning a
        value, an output Message Channel may also be provided.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          The output channel is optional, since each Message may also provide its own 'Return Address' header. This
          same rule applies for all consumer endpoints.
        </td></tr></tbody></table></div><p>
        The Service Activator invokes an operation on some service object to process the request Message, extracting
        the request Message's payload and converting if necessary (if the method does not expect a Message-typed
        parameter). Whenever the service object's method returns a value, that return value will likewise be converted
        to a reply Message if necessary (if it's not already a Message). That reply Message is sent to the output
        channel. If no output channel has been configured, then the reply will be sent to the channel specified in the
        Message's "return address" if available.
        </p><div class="mediaobject" align="center"><img src="./Spring Integration Reference Manual_files/handler-endpoint.png" align="middle"><div class="caption">
            A request-reply "Service Activator" endpoint connects a target object's method to input and output
            Message Channels.
          </div></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="overview-endpoints-channeladapter"></a>Channel Adapter</h3></div></div></div><p>
        A Channel Adapter is an endpoint that connects a Message Channel to some other system or transport. Channel
        Adapters may be either inbound or outbound. Typically, the Channel Adapter will do some mapping between the
        Message and whatever object or resource is received-from or sent-to the other system (File, HTTP Request, JMS
        Message, etc). Depending on the transport, the Channel Adapter may also populate or extract Message header
        values. Spring Integration provides a number of Channel Adapters, and they will be described in upcoming
        chapters.
        </p><div class="mediaobject" align="center"><img src="./Spring Integration Reference Manual_files/source-endpoint.png" align="middle"><div class="caption">An inbound "Channel Adapter" endpoint connects a source system to a MessageChannel.</div></div><p>
        </p><div class="mediaobject" align="center"><img src="./Spring Integration Reference Manual_files/target-endpoint.png" align="middle"><div class="caption">An outbound "Channel Adapter" endpoint connects a MessageChannel to a target system.</div></div><p>
      </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="message"></a>2.&nbsp;Message Construction</h2></div></div></div><p>
    The Spring Integration <code class="interfacename">Message</code> is a generic container for data. Any object can
    be provided as the payload, and each <code class="interfacename">Message</code> also includes headers containing
    user-extensible properties as key-value pairs.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-interface"></a>2.1&nbsp;The Message Interface</h2></div></div></div><p>Here is the definition of the <code class="interfacename">Message</code> interface:
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Message&lt;T&gt; {

    T getPayload();

    MessageHeaders getHeaders();

}</pre><p>
    </p><p>
      The <code class="interfacename">Message</code> is obviously a very important part of the API. By encapsulating the
      data in a generic wrapper, the messaging system can pass it around without any knowledge of the data's type. As
      an application evolves to support new types, or when the types themselves are modified and/or extended, the
      messaging system will not be affected by such changes. On the other hand, when some component in the messaging
      system <span class="emphasis"><em>does</em></span> require access to information about the <code class="interfacename">Message</code>,
      such metadata can typically be stored to and retrieved from the metadata in the Message Headers.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-headers"></a>2.2&nbsp;Message Headers</h2></div></div></div><p>
      Just as Spring Integration allows any Object to be used as the payload of a Message, it also supports any Object
      types as header values. In fact, the <code class="classname">MessageHeaders</code> class implements the
      <span class="emphasis"><em>java.util.Map</em></span> interface:
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> MessageHeaders <span class="hl-keyword">implements</span> Map&lt;String, Object&gt;, Serializable {
	...
}</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        Even though the MessageHeaders implements Map, it is effectively a read-only implementation. Any attempt to
        <span class="emphasis"><em>put</em></span> a value in the Map will result in an <code class="classname">UnsupportedOperationException</code>.
        The same applies for <span class="emphasis"><em>remove</em></span> and <span class="emphasis"><em>clear</em></span>. Since Messages may be passed to
        multiple consumers, the structure of the Map cannot be modified. Likewise, the Message's payload Object can not
        be <span class="emphasis"><em>set</em></span> after the initial creation. However, the mutability of the header values themselves
        (or the payload Object) is intentionally left as a decision for the framework user.
      </td></tr></tbody></table></div><p>
    </p><p>
      As an implementation of Map, the headers can obviously be retrieved by calling <code class="methodname">get(..)</code>
      with the name of the header. Alternatively, you can provide the expected <span class="emphasis"><em>Class</em></span> as an
      additional parameter. Even better, when retrieving one of the pre-defined values, convenient getters are
      available. Here is an example of each of these three options:
      </p><pre class="programlisting"> Object someValue = message.getHeaders().get(<span class="hl-string">"someKey"</span>);

 CustomerId customerId = message.getHeaders().get(<span class="hl-string">"customerId"</span>, CustomerId.<span class="hl-keyword">class</span>);

 Long timestamp = message.getHeaders().getTimestamp();
 </pre><p>
    </p><p>
      The following Message headers are pre-defined:
      </p><div class="table"><a name="message-headers-table"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Pre-defined Message Headers</b></p><div class="table-contents"><table summary="Pre-defined Message Headers" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="center">Header Name</th><th style="border-bottom: 0.5pt solid ; " align="center">Header Type</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">ID</td><td style="border-bottom: 0.5pt solid ; ">java.util.UUID</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">TIMESTAMP</td><td style="border-bottom: 0.5pt solid ; ">java.lang.Long</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">EXPIRATION_DATE</td><td style="border-bottom: 0.5pt solid ; ">java.lang.Long</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">CORRELATION_ID</td><td style="border-bottom: 0.5pt solid ; ">java.lang.Object</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">REPLY_CHANNEL</td><td style="border-bottom: 0.5pt solid ; ">java.lang.Object (can be a String or MessageChannel)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">ERROR_CHANNEL</td><td style="border-bottom: 0.5pt solid ; ">java.lang.Object (can be a String or MessageChannel)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">SEQUENCE_NUMBER</td><td style="border-bottom: 0.5pt solid ; ">java.lang.Integer</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">SEQUENCE_SIZE</td><td style="border-bottom: 0.5pt solid ; ">java.lang.Integer</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">PRIORITY</td><td style="">MessagePriority (an <span class="emphasis"><em>enum</em></span>)</td></tr></tbody></table></div></div><p><br class="table-break">
    </p><p>
      Many inbound and outbound adapter implementations will also provide and/or expect certain headers, and additional
      user-defined headers can also be configured.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-implementations"></a>2.3&nbsp;Message Implementations</h2></div></div></div><p>
      The base implementation of the <code class="interfacename">Message</code> interface is
      <code class="classname">GenericMessage&lt;T&gt;</code>, and it provides two constructors:
      </p><pre class="programlisting"><span class="hl-keyword">new</span> GenericMessage&lt;T&gt;(T payload);

<span class="hl-keyword">new</span> GenericMessage&lt;T&gt;(T payload, Map&lt;String, Object&gt; headers)</pre><p>
      When a Message is created, a random unique id will be generated. The constructor that accepts a Map of headers
      will copy the provided headers to the newly created Message.
    </p><p>
	  There are also two convenient subclasses available: <code class="classname">StringMessage</code> and
      <code class="classname">ErrorMessage</code>. The former accepts a String as its payload:
      </p><pre class="programlisting">StringMessage message = <span class="hl-keyword">new</span> StringMessage(<span class="hl-string">"hello world"</span>);

String s = message.getPayload();</pre><p>
      And, the latter accepts any <code class="classname">Throwable</code> object as its payload:
      </p><pre class="programlisting">ErrorMessage message = <span class="hl-keyword">new</span> ErrorMessage(someThrowable);

Throwable t = message.getPayload();</pre><p>
      Notice that these implementations take advantage of the fact that the <code class="classname">GenericMessage</code>
      base class is parameterized. Therefore, as shown in both examples, no casting is necessary when retrieving
      the Message payload Object.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-builder"></a>2.4&nbsp;The MessageBuilder Helper Class</h2></div></div></div><p>
      You may notice that the Message interface defines retrieval methods for its payload and headers but no setters.
      The reason for this is that a Message cannot be modified after its initial creation. Therefore, when a Message
      instance is sent to multiple consumers (e.g. through a Publish Subscribe Channel), if one of those consumers
      needs to send a reply with a different payload type, it will need to create a new Message. As a result, the
      other consumers are not affected by those changes. Keep in mind, that multiple consumers may access the same
      payload instance or header value, and whether such an instance is itself immutable is a decision left to the
      developer. In other words, the contract for Messages is similar to that of an
      <span class="emphasis"><em>unmodifiable Collection</em></span>, and the MessageHeaders' map further exemplifies that; even though
      the MessageHeaders class implements <code class="interfacename">java.util.Map</code>, any attempt to invoke a
      <span class="emphasis"><em>put</em></span> operation (or 'remove' or 'clear') on the MessageHeaders will result in an
      <code class="classname">UnsupportedOperationException</code>.
    </p><p>
      Rather than requiring the creation and population of a Map to pass into the GenericMessage constructor, Spring
      Integration does provide a far more convenient way to construct Messages: <code class="classname">MessageBuilder</code>.
      The MessageBuilder provides two factory methods for creating Messages from either an existing Message or with a
      payload Object. When building from an existing Message, the headers <span class="emphasis"><em>and payload</em></span> of that
      Message will be copied to the new Message:
      </p><pre class="programlisting">Message&lt;String&gt; message1 = MessageBuilder.withPayload(<span class="hl-string">"test"</span>)
        .setHeader(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>)
        .build();

Message&lt;String&gt; message2 = MessageBuilder.fromMessage(message1).build();

assertEquals(<span class="hl-string">"test"</span>, message2.getPayload());
assertEquals(<span class="hl-string">"bar"</span>, message2.getHeaders().get(<span class="hl-string">"foo"</span>));</pre><p>
    </p><p>
      If you need to create a Message with a new payload but still want to copy the
      headers from an existing Message, you can use one of the 'copy' methods.
      </p><pre class="programlisting">Message&lt;String&gt; message3 = MessageBuilder.withPayload(<span class="hl-string">"test3"</span>)
        .copyHeaders(message1.getHeaders())
        .build();

Message&lt;String&gt; message4 = MessageBuilder.withPayload(<span class="hl-string">"test4"</span>)
        .setHeader(<span class="hl-string">"foo"</span>, 123)
        .copyHeadersIfAbsent(message1.getHeaders())
        .build();

assertEquals(<span class="hl-string">"bar"</span>, message3.getHeaders().get(<span class="hl-string">"foo"</span>));
assertEquals(123, message4.getHeaders().get(<span class="hl-string">"foo"</span>));</pre><p>
      Notice that the <code class="methodname">copyHeadersIfAbsent</code> does not overwrite existing values. Also, in the
      second example above, you can see how to set any user-defined header with <code class="methodname">setHeader</code>.
      Finally, there are set methods available for the predefined headers as well as a non-destructive method for
      setting any header (MessageHeaders also defines constants for the pre-defined header names).
      </p><pre class="programlisting">Message&lt;Integer&gt; importantMessage = MessageBuilder.withPayload(99)
        .setPriority(MessagePriority.HIGHEST)
        .build();

assertEquals(MessagePriority.HIGHEST, importantMessage.getHeaders().getPriority());

Message&lt;Integer&gt; anotherMessage = MessageBuilder.fromMessage(importantMessage)
        .setHeaderIfAbsent(MessageHeaders.PRIORITY, MessagePriority.LOW)
        .build();

assertEquals(MessagePriority.HIGHEST, anotherMessage.getHeaders().getPriority());
</pre><p>
    </p><p>
      The <code class="classname">MessagePriority</code> is only considered when using a <code class="classname">PriorityChannel</code>
      (as described in the next chapter). It is defined as an <span class="emphasis"><em>enum</em></span> with five possible values:
      </p><pre class="programlisting"><span class="hl-keyword">public</span> enum MessagePriority {
    HIGHEST,
    HIGH,
    NORMAL,
    LOW,
    LOWEST
}</pre><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="channel"></a>3.&nbsp;Message Channels</h2></div></div></div><p>
    While the <code class="interfacename">Message</code> plays the crucial role of encapsulating data, it is the
    <code class="interfacename">MessageChannel</code> that decouples message producers from message consumers.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="channel-interfaces"></a>3.1&nbsp;The MessageChannel Interface</h2></div></div></div><p>
      Spring Integration's top-level <code class="interfacename">MessageChannel</code> interface is defined as follows.
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MessageChannel {

    String getName();

    <span class="hl-keyword">boolean</span> send(Message message);

    <span class="hl-keyword">boolean</span> send(Message message, <span class="hl-keyword">long</span> timeout);
}</pre><p>
      When sending a message, the return value will be <span class="emphasis"><em>true</em></span> if the message is sent successfully.
      If the send call times out or is interrupted, then it will return <span class="emphasis"><em>false</em></span>.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-interfaces-pollablechannel"></a>PollableChannel</h3></div></div></div><p>
        Since Message Channels may or may not buffer Messages (as discussed in the overview), there are two
        sub-interfaces defining the buffering (pollable) and non-buffering (subscribable) channel behavior. Here is the
        definition of <code class="interfacename">PollableChannel</code>.
        </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> PollableChannel <span class="hl-keyword">extends</span> MessageChannel {

    Message&lt;?&gt; receive();

    Message&lt;?&gt; receive(<span class="hl-keyword">long</span> timeout);

    List&lt;Message&lt;?&gt;&gt; clear();

    List&lt;Message&lt;?&gt;&gt; purge(MessageSelector selector);

}</pre><p>
        Similar to the send methods, when receiving a message, the return value will be <span class="emphasis"><em>null</em></span> in the
        case of a timeout or interrupt.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-interfaces-subscribablechannel"></a>SubscribableChannel</h3></div></div></div><p>
        The <code class="interfacename">SubscribableChannel</code> base interface is implemented by channels that send
        Messages directly to their subscribed <code class="interfacename">MessageHandler</code>s. Therefore, they do not
        provide receive methods for polling, but instead define methods for managing those subscribers:
        </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> SubscribableChannel <span class="hl-keyword">extends</span> MessageChannel {

    <span class="hl-keyword">boolean</span> subscribe(MessageHandler handler);

    <span class="hl-keyword">boolean</span> unsubscribe(MessageHandler handler);

}</pre><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="channel-implementations"></a>3.2&nbsp;Message Channel Implementations</h2></div></div></div><p>
      Spring Integration provides several different Message Channel implementations. Each is briefly described in the
      sections below.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-implementations-publishsubscribechannel"></a>PublishSubscribeChannel</h3></div></div></div><p>
        The <code class="classname">PublishSubscribeChannel</code> implementation broadcasts any Message
        sent to it to all of its subscribed handlers. This is most often used for sending
        <span class="emphasis"><em>Event Messages</em></span> whose primary role is notification as opposed to
        <span class="emphasis"><em>Document Messages</em></span> which are generally intended to be processed by
        a single handler. Note that the <code class="classname">PublishSubscribeChannel</code> is
        intended for sending only. Since it broadcasts to its subscribers directly when its
        <code class="methodname">send(Message)</code> method is invoked, consumers cannot poll for
        Messages (it does not implement <code class="interfacename">PollableChannel</code> and
        therefore has no <code class="methodname">receive()</code> method). Instead, any subscriber
        must be a <code class="interfacename">MessageHandler</code> itself, and the subscriber's
        <code class="methodname">handleMessage(Message)</code> method will be invoked in turn.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-implementations-queuechannel"></a>QueueChannel</h3></div></div></div><p>
        The <code class="classname">QueueChannel</code> implementation wraps a queue. Unlike, the
        <code class="classname">PublishSubscribeChannel</code>, the <code class="classname">QueueChannel</code> has point-to-point
        semantics. In other words, even if the channel has multiple consumers, only one of them should receive any
        Message sent to that channel. It provides a default no-argument constructor (providing an essentially unbounded
        capacity of <code class="code">Integer.MAX_VALUE</code>) as well as a constructor that accepts the queue capacity:
        </p><pre class="programlisting"><span class="hl-keyword">public</span> QueueChannel(<span class="hl-keyword">int</span> capacity)</pre><p>
        A channel that has not reached its capacity limit will store messages in its internal queue, and the
        <code class="methodname">send()</code> method will return immediately even if no receiver is ready to handle the
        message. If the queue has reached capacity, then the sender will block until room is available. Or, if using
        the send call that accepts a timeout, it will block until either room is available or the timeout period
        elapses, whichever occurs first. Likewise, a receive call will return immediately if a message is available
        on the queue, but if the queue is empty, then a receive call may block until either a message is available
        or the timeout elapses. In either case, it is possible to force an immediate return regardless of the
        queue's state by passing a timeout value of 0. The no-argument send and receive methods block indefinitely.
        Note however, that calling the no-arg versions of <code class="methodname">send()</code> and
        <code class="methodname">receive()</code> will block indefinitely.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-implementations-prioritychannel"></a>PriorityChannel</h3></div></div></div><p>
        Whereas the <code class="classname">QueueChannel</code> enforces first-in/first-out (FIFO) ordering, the
        <code class="classname">PriorityChannel</code> is an alternative implementation that allows for messages
        to be ordered within the channel based upon a priority. By default the priority is determined by the
        '<code class="literal">priority</code>' header within each message. However, for custom priority determination
        logic, a comparator of type <code class="classname">Comparator&lt;Message&lt;?&gt;&gt;</code> can be provided
        to the <code class="classname">PriorityChannel</code>'s constructor.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-implementations-rendezvouschannel"></a>RendezvousChannel</h3></div></div></div><p>
        The <code class="classname">RendezvousChannel</code> enables a "direct-handoff" scenario where a sender will block
        until another party invokes the channel's <code class="methodname">receive()</code> method or vice-versa. Internally,
        this implementation is quite similar to the <code class="classname">QueueChannel</code> except that it uses a
        <code class="classname">SynchronousQueue</code> (a zero-capacity implementation of
        <code class="interfacename">BlockingQueue</code>). This works well in situations where the sender and receiver are
        operating in different threads but simply dropping the message in a queue asynchronously is not appropriate.
        In other words, with a <code class="classname">RendezvousChannel</code> at least the sender knows that some receiver
        has accepted the message, whereas with a <code class="classname">QueueChannel</code>, the message would have been
        stored to the internal queue and potentially never received.
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
          Keep in mind that all of these queue-based channels are storing messages in-memory only. When persistence
          is required, you can either invoke a database operation within a handler or use Spring Integration's
          support for JMS-based Channel Adapters. The latter option allows you to take advantage of any JMS provider's
          implementation for message persistence, and it will be discussed in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#jms" title="18.Â JMS Support">Chapter&nbsp;18, <i>JMS Support</i></a>. However, when
          buffering in a queue is not necessary, the simplest approach is to rely upon the
          <code class="classname">DirectChannel</code> discussed next.
        </p></td></tr></tbody></table></div><p>
        The <code class="classname">RendezvousChannel</code> is also useful for implementing request-reply
        operations. The sender can create a temporary, anonymous instance of <code class="classname">RendezvousChannel</code>
        which it then sets as the 'replyChannel' header when building a Message. After sending that Message, the sender
        can immediately call receive (optionally providing a timeout value) in order to block while waiting for a reply
        Message. This is very similar to the implementation used internally by many of Spring Integration's
        request-reply components.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-implementations-directchannel"></a>DirectChannel</h3></div></div></div><p>
        The <code class="classname">DirectChannel</code> has point-to-point semantics but otherwise is more similar to the
        <code class="classname">PublishSubscribeChannel</code> than any of the queue-based channel implementations described
        above. It implements the <code class="interfacename">SubscribableChannel</code> interface instead of the
        <code class="interfacename">PollableChannel</code> interface, so it dispatches Messages directly to a subscriber.
        As a point-to-point channel, however, it differs from the <code class="classname">PublishSubscribeChannel</code> in
        that it will only send each Message to a <span class="emphasis"><em>single</em></span> subscribed
        <code class="classname">MessageHandler</code>.
      </p><p>
        In addition to being the simplest point-to-point channel option, one of its most important features is that
        it enables a single thread to perform the operations on "both sides" of the channel. For example, if a handler
        is subscribed to a <code class="classname">DirectChannel</code>, then sending a Message to that channel will trigger
        invocation of that handler's <code class="methodname">handleMessage(Message)</code> method <span class="emphasis"><em>directly in the
        sender's thread</em></span>, before the send() method invocation can return.
      </p><p>
        The key motivation for providing a channel implementation with this behavior is to support transactions that
        must span across the channel while still benefiting from the abstraction and loose coupling that the channel
        provides. If the send call is invoked within the scope of a transaction, then the outcome of the handler's
        invocation (e.g. updating a database record) will play a role in determining the ultimate result of that
        transaction (commit or rollback).
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          Since the <code class="classname">DirectChannel</code> is the simplest option and does not add any additional
          overhead that would be required for scheduling and managing the threads of a poller, it is the default
          channel type within Spring Integration. The general idea is to define the channels for an application and
          then to consider which of those need to provide buffering or to throttle input, and then modify those to
          be queue-based <code class="interfacename">PollableChannels</code>. Likewise, if a channel needs to broadcast
          messages, it should not be a <code class="classname">DirectChannel</code> but rather a
          <code class="classname">PublishSubscribeChannel</code>. Below you will see how each of these can be configured.
        </td></tr></tbody></table></div><p>
      </p><p>
        The <code class="classname">DirectChannel</code> internally delegates to a Message Dispatcher to invoke its
        subscribed Message Handlers, and that dispatcher can have a load-balancing strategy. The load-balancer
        determines how invocations will be ordered in the case that there are multiple handlers subscribed to the
        same channel. When using the namespace support described below, the default strategy is
        "round-robin" which essentially load-balances across the handlers in rotation.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          The "round-robin" strategy is currently the only implementation available out-of-the-box in Spring
          Integration. Other strategy implementations may be added in future versions.
        </td></tr></tbody></table></div><p>
      </p><p>
        The load-balancer also works in combination with a boolean <span class="emphasis"><em>failover</em></span> property.
        If the "failover" value is true (the default), then the dispatcher will fall back to any subsequent
        handlers as necessary when preceding handlers throw Exceptions. The order is determined by an optional
        order value defined on the handlers themselves or, if no such value exists, the order in which the
        handlers are subscribed.
      </p><p>
        If a certain situation requires that the dispatcher always try to invoke the first handler, then
        fallback in the same fixed order sequence every time an error occurs, no load-balancing strategy should
        be provided. In other words, the dispatcher still supports the failover boolean property even when no
        load-balancing is enabled. Without load-balancing, however, the invocation of handlers will always begin
        with the first according to their order. For example, this approach works well when there is a clear
        definition of primary, secondary, tertiary, and so on. When using the namespace support, the "order"
        attribute on any endpoint will determine that order.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          Keep in mind that load-balancing and failover only apply when a channel has more than one
          subscribed Message Handler. When using the namespace support, this means that more than one
          endpoint shares the same channel reference in the "input-channel" attribute.
       </td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="executor-channel"></a>ExecutorChannel</h3></div></div></div><p>
        The <code class="classname">ExecutorChannel</code> is a point-to-point channel that supports
        the same dispatcher configuration as <code class="classname">DirectChannel</code> (load-balancing strategy
        and the failover boolean property). The key difference between these two dispatching channel types
        is that the <code class="classname">ExecutorChannel</code> delegates to an instance of
        <code class="interfacename">TaskExecutor</code> to perform the dispatch. This means that the send method
        typically will not block, but it also means that the handler invocation may not occur in the sender's
        thread. It therefore <span class="emphasis"><em>does not support transactions spanning the sender and receiving
        handler</em></span>.
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
	      Note that there are occasions where the sender may block. For example, when using a
	      TaskExecutor with a rejection-policy that throttles back on the client (such as the
          <code class="code">ThreadPoolExecutor.CallerRunsPolicy</code>), the sender's thread will execute
          the method directly anytime the thread pool is at its maximum capacity and the
          executor's work queue is full. Since that situation would only occur in a non-predictable
          way, that obviously cannot be relied upon for transactions.
        </td></tr></tbody></table></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-implementations-threadlocalchannel"></a>ThreadLocalChannel</h3></div></div></div><p>
        The final channel implementation type is <code class="classname">ThreadLocalChannel</code>. This channel also delegates
        to a queue internally, but the queue is bound to the current thread. That way the thread that sends to the
        channel will later be able to receive those same Messages, but no other thread would be able to access them.
        While probably the least common type of channel, this is useful for situations where
        <code class="classname">DirectChannels</code> are being used to enforce a single thread of operation but any reply
        Messages should be sent to a "terminal" channel. If that terminal channel is a
        <code class="classname">ThreadLocalChannel</code>, the original sending thread can collect its replies from it.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="channel-interceptors"></a>3.3&nbsp;Channel Interceptors</h2></div></div></div><p>
      One of the advantages of a messaging architecture is the ability to provide common behavior and capture
      meaningful information about the messages passing through the system in a non-invasive way. Since the
      <code class="interfacename">Messages</code> are being sent to and received from
      <code class="interfacename">MessageChannels</code>, those channels provide an opportunity for intercepting
      the send and receive operations. The <code class="interfacename">ChannelInterceptor</code> strategy interface
      provides methods for each of those operations:
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> ChannelInterceptor {

    Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel);

    <span class="hl-keyword">void</span> postSend(Message&lt;?&gt; message, MessageChannel channel, <span class="hl-keyword">boolean</span> sent);

    <span class="hl-keyword">boolean</span> preReceive(MessageChannel channel);

    Message&lt;?&gt; postReceive(Message&lt;?&gt; message, MessageChannel channel);
}</pre><p>
      After implementing the interface, registering the interceptor with a channel is just a matter of calling:
      </p><pre class="programlisting">channel.addInterceptor(someChannelInterceptor);</pre><p>
      The methods that return a Message instance can be used for transforming the Message or can return 'null'
      to prevent further processing (of course, any of the methods can throw a RuntimeException). Also, the
      <code class="methodname">preReceive</code> method can return '<code class="literal">false</code>' to prevent the receive
      operation from proceeding.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        Keep in mind that <code class="methodname">receive()</code> calls are only relevant for
        <code class="interfacename">PollableChannels</code>. In fact the
        <code class="interfacename">SubscribableChannel</code> interface does not even define a
        <code class="methodname">receive()</code> method. The reason for this is that when a Message is sent to a
        <code class="interfacename">SubscribableChannel</code> it will be sent directly to one or more subscribers
        depending on the type of channel (e.g. a PublishSubscribeChannel sends to all of its subscribers). Therefore,
        the <code class="methodname">preReceive(..)</code> and <code class="methodname">postReceive(..)</code> interceptor methods
        are only invoked when the interceptor is applied to a <code class="interfacename">PollableChannel</code>.
      </td></tr></tbody></table></div><p>
      Spring Integration also provides an implementation of the
      <a class="ulink" href="http://eaipatterns.com/WireTap.html" target="_top">Wire Tap</a> pattern.
      It is a simple interceptor that sends the Message to another channel without otherwise altering the
      existing flow. It can be very useful for debugging and monitoring. An example is shown in
      <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-wiretap" title="Wire Tap">the section called âWire Tapâ</a>.
    </p><p>
      Because it is rarely necessary to implement all of the interceptor methods, a
      <code class="classname">ChannelInterceptorAdapter</code> class is also available for sub-classing. It provides no-op
      methods (the <code class="literal">void</code> method is empty, the <code class="classname">Message</code> returning methods
      return the Message as-is, and the <code class="literal">boolean</code> method returns <code class="literal">true</code>).
      Therefore, it is often easiest to extend that class and just implement the method(s) that you need as in the
      following example.
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CountingChannelInterceptor <span class="hl-keyword">extends</span> ChannelInterceptorAdapter {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> AtomicInteger sendCount = <span class="hl-keyword">new</span> AtomicInteger();

    @Override
    <span class="hl-keyword">public</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {
        sendCount.incrementAndGet();
        <span class="hl-keyword">return</span> message;
    }
}</pre><p>
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
        The order of invocation for the interceptor methods depends on the type of channel. As described above,
        the queue-based channels are the only ones where the receive method is intercepted in the first place.
        Additionally, the relationship between send and receive interception depends on the timing of separate
        sender and receiver threads. For example, if a receiver is already blocked while waiting for a message
        the order could be: preSend, preReceive, postReceive, postSend. However, if a receiver polls after the
        sender has placed a message on the channel and already returned, the order would be: preSend, postSend,
        (some-time-elapses) preReceive, postReceive. The time that elapses in such a case depends on a number
        of factors and is therefore generally unpredictable (in fact, the receive may never happen!).
        Obviously, the type of queue also plays a role (e.g. rendezvous vs. priority). The bottom line is that
        you cannot rely on the order beyond the fact that preSend will precede postSend and preReceive will
        precede postReceive.
      </td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="channel-template"></a>3.4&nbsp;MessageChannelTemplate</h2></div></div></div><p>
      As you will see when the endpoints and their various configuration options are introduced, Spring Integration
      provides a foundation for messaging components that enables non-invasive invocation of your application code
      <span class="emphasis"><em>from the messaging system</em></span>. However, sometimes it is necessary to invoke the messaging system
      <span class="emphasis"><em>from your application code</em></span>. For convenience when implementing such use-cases, Spring
      Integration provides a <code class="classname">MessageChannelTemplate</code> that supports a variety of operations across
      the Message Channels, including request/reply scenarios. For example, it is possible to send a request
      and wait for a reply.
      </p><pre class="programlisting">MessageChannelTemplate template = <span class="hl-keyword">new</span> MessageChannelTemplate();

Message reply = template.sendAndReceive(<span class="hl-keyword">new</span> StringMessage(<span class="hl-string">"test"</span>), someChannel);</pre><p>
      In that example, a temporary anonymous channel would be created internally by the template. The
      'sendTimeout' and 'receiveTimeout' properties may also be set on the template, and other exchange
      types are also supported.
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> send(<span class="hl-keyword">final</span> Message&lt;?&gt; message, <span class="hl-keyword">final</span> MessageChannel channel) { ... }

<span class="hl-keyword">public</span> Message&lt;?&gt; sendAndReceive(<span class="hl-keyword">final</span> Message&lt;?&gt; request, <span class="hl-keyword">final</span> MessageChannel channel) { .. }

<span class="hl-keyword">public</span> Message&lt;?&gt; receive(<span class="hl-keyword">final</span> PollableChannel&lt;?&gt; channel) { ... }</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        A less invasive approach that allows you to invoke simple interfaces with payload and/or header
        values instead of Message instances is described in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#gateway-proxy" title="16.2Â GatewayProxyFactoryBean">Section&nbsp;16.2, âGatewayProxyFactoryBeanâ</a>.
      </p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="channel-configuration"></a>3.5&nbsp;Configuring Message Channels</h2></div></div></div><p>
      To create a Message Channel instance, you can use the 'channel' element:
      </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleChannel"</span>/&gt;</pre><p>
    </p><p>
      The default channel type is <span class="emphasis"><em>Point to Point</em></span>. To create a
      <span class="emphasis"><em>Publish Subscribe</em></span> channel, use the "publish-subscribe-channel" element:
      </p><pre class="programlisting">&lt;<span class="hl-tag">publish-subscribe-channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleChannel"</span>/&gt;</pre><p>
    </p><p>
      To create a <a class="ulink" href="http://www.eaipatterns.com/DatatypeChannel.html" target="_top">Datatype Channel</a> that only
      accepts messages containing a certain payload type, provide the fully-qualified class name in the
      channel element's <code class="literal">datatype</code> attribute:
      </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"numberChannel"</span> <span class="hl-attribute">datatype</span>=<span class="hl-value">"java.lang.Number"</span>/&gt;</pre><p>
      Note that the type check passes for any type that is <span class="emphasis"><em>assignable</em></span> to the channel's
      datatype. In other words, the "numberChannel" above would accept messages whose payload is
      <code class="classname">java.lang.Integer</code> or <code class="classname">java.lang.Double</code>. Multiple types can be
      provided as a comma-delimited list:
      </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"stringOrNumberChannel"</span> <span class="hl-attribute">datatype</span>=<span class="hl-value">"java.lang.String,java.lang.Number"</span>/&gt;</pre><p> 
    </p><p>
      When using the "channel" element without any sub-elements, it will create a <code class="classname">DirectChannel</code>
      instance (a <code class="interfacename">SubscribableChannel</code>).
    </p><p>
      However, you can alternatively provide a variety of "queue" sub-elements to create any of
      the pollable channel types (as described in
      <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-implementations" title="3.2Â Message Channel Implementations">Section&nbsp;3.2, âMessage Channel Implementationsâ</a>). Examples of each are shown below.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-configuration-directchannel"></a>DirectChannel Configuration</h3></div></div></div><p>
        As mentioned above, <code class="classname">DirectChannel</code> is the default type.
        </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"directChannel"</span>/&gt;</pre><p>
      </p><p>
        A default channel will have a <span class="emphasis"><em>round-robin</em></span> load-balancer and will also have
        failover enabled (See the discussion in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-implementations-directchannel" title="DirectChannel">the section called âDirectChannelâ</a>
        for more detail). To disable one or both of these, add a &lt;dispatcher/&gt; sub-element and
        configure the attributes:
        </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"failFastChannel"</span>&gt;
    &lt;<span class="hl-tag">dispatcher</span> <span class="hl-attribute">failover</span>=<span class="hl-value">"false"</span>/&gt;
&lt;<span class="hl-tag">/channel</span>&gt;

&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"channelWithFixedOrderSequenceFailover"</span>&gt;
    &lt;<span class="hl-tag">dispatcher</span> <span class="hl-attribute">load-balancer</span>=<span class="hl-value">"none"</span>/&gt;
&lt;<span class="hl-tag">/channel</span>&gt;
</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-configuration-queuechannel"></a>QueueChannel Configuration</h3></div></div></div><p>
        To create a <code class="classname">QueueChannel</code>, use the "queue" sub-element.
        You may specify the channel's capacity:
        </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"queueChannel"</span>&gt;
    &lt;<span class="hl-tag">queue</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"25"</span>/&gt;
&lt;<span class="hl-tag">/channel</span>&gt;</pre><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          If you do not provide a value for the 'capacity' attribute on this &lt;queue/&gt; sub-element,
          the resulting queue will be unbounded. To avoid issues such as OutOfMemoryErrors, it is highly
          recommended to set an explicit value for a bounded queue.
        </td></tr></tbody></table></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-configuration-pubsubchannel"></a>PublishSubscribeChannel Configuration</h3></div></div></div><p>
        To create a <code class="classname">PublishSubscribeChannel</code>, use the "publish-subscribe-channel" element.
        When using this element, you can also specify the "task-executor" used for publishing
        Messages (if none is specified it simply publishes in the sender's thread): 
        </p><pre class="programlisting">&lt;<span class="hl-tag">publish-subscribe-channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pubsubChannel"</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"someExecutor"</span>/&gt;</pre><p>
        If you are providing a <span class="emphasis"><em>Resequencer</em></span> or <span class="emphasis"><em>Aggregator</em></span> downstream
        from a <code class="classname">PublishSubscribeChannel</code>, then you can set the 'apply-sequence' property
        on the channel to <code class="code">true</code>. That will indicate that the channel should set the sequence-size
        and sequence-number Message headers as well as the correlation id prior to passing the Messages along.
        For example, if there are 5 subscribers, the sequence-size would be set to 5, and the Messages would
        have sequence-number header values ranging from 1 to 5.
        </p><pre class="programlisting">&lt;<span class="hl-tag">publish-subscribe-channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pubsubChannel"</span> <span class="hl-attribute">apply-sequence</span>=<span class="hl-value">"true"</span>/&gt;</pre><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
          The 'apply-sequence' value is <code class="code">false</code> by default so that a Publish Subscribe Channel
          can send the exact same Message instances to multiple outbound channels. Since Spring Integration
          enforces immutability of the payload and header references, the channel creates new Message
          instances with the same payload reference but different header values when the flag is set to
          <code class="code">true</code>. 
        </td></tr></tbody></table></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-configuration-executorchannel"></a>ExecutorChannel</h3></div></div></div><p>
        To create an <code class="classname">ExecutorChannel</code>, add the &lt;dispatcher&gt; sub-element along
        with a 'task-executor' attribute. Its value can reference any <code class="interfacename">TaskExecutor</code>
        within the context. For example, this enables configuration of a thread-pool for dispatching messages
        to subscribed handlers. As mentioned above, this does break the "single-threaded" execution context
        between sender and receiver so that any active transaction context will not be shared by the invocation
        of the handler (i.e. the handler may throw an Exception, but the send invocation has already returned
        successfully).
        </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"executorChannel"</span>&gt;
    &lt;<span class="hl-tag">dispatcher</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"someExecutor"</span>/&gt;
&lt;<span class="hl-tag">/channel</span>&gt;</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        The "load-balancer" and "failover" options are also both available on the dispatcher sub-element
        as described above in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-configuration-directchannel" title="DirectChannel Configuration">the section called âDirectChannel Configurationâ</a>. The same defaults
        apply as well. So, the channel will have a round-robin load-balancing strategy with failover
        enabled unless explicit configuration is provided for one or both of those attributes.
        <pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"executorChannelWithoutFailover"</span>&gt;
    &lt;<span class="hl-tag">dispatcher</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"someExecutor"</span> <span class="hl-attribute">failover</span>=<span class="hl-value">"false"</span>/&gt;
&lt;<span class="hl-tag">/channel</span>&gt;</pre></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-configuration-prioritychannel"></a>PriorityChannel Configuration</h3></div></div></div><p>
        To create a <code class="classname">PriorityChannel</code>, use the "priority-queue" sub-element:
        </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"priorityChannel"</span>&gt;
    &lt;<span class="hl-tag">priority-queue</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"20"</span>/&gt;
&lt;<span class="hl-tag">/channel</span>&gt;</pre><p>
        By default, the channel will consult the <code class="classname">MessagePriority</code> header of the 
        message. However, a custom <code class="interfacename">Comparator</code> reference may be
        provided instead. Also, note that the <code class="classname">PriorityChannel</code> (like the other types)
        does support the "datatype" attribute. As with the QueueChannel, it also supports a "capacity" attribute.
        The following example demonstrates all of these:
        </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"priorityChannel"</span> <span class="hl-attribute">datatype</span>=<span class="hl-value">"example.Widget"</span>&gt;
    &lt;<span class="hl-tag">priority-queue</span> <span class="hl-attribute">comparator</span>=<span class="hl-value">"widgetComparator"</span>
                    <span class="hl-attribute">capacity</span>=<span class="hl-value">"10"</span>/&gt;
&lt;<span class="hl-tag">/channel</span>&gt;
</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-configuration-rendezvouschannel"></a>RendezvousChannel Configuration</h3></div></div></div><p>
        A <code class="classname">RendezvousChannel</code> is created when the queue sub-element is
        a &lt;rendezvous-queue&gt;. It does not provide any additional configuration options to
        those described above, and its queue does not accept any capacity value since it is a
        0-capacity direct handoff queue.
        </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rendezvousChannel"</span>/&gt;
    &lt;<span class="hl-tag">rendezvous-queue</span>/&gt;
&lt;<span class="hl-tag">/channel</span>&gt;
</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-configuration-threadlocalchannel"></a>ThreadLocalChannel Configuration</h3></div></div></div><p>
        The <code class="classname">ThreadLocalChannel</code> does not provide any additional configuration options.
        </p><pre class="programlisting">&lt;<span class="hl-tag">thread-local-channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"threadLocalChannel"</span>/&gt;</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-configuration-interceptors"></a>Channel Interceptor Configuration</h3></div></div></div><p>
        Message channels may also have interceptors as described in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-interceptors" title="3.3Â Channel Interceptors">Section&nbsp;3.3, âChannel Interceptorsâ</a>. The
        &lt;interceptors&gt; sub-element can be added within &lt;channel&gt; (or the more specific element
        types). Provide the "ref" attribute to reference any Spring-managed object that implements the
        <code class="interfacename">ChannelInterceptor</code> interface:
        </p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleChannel"</span>&gt;
    &lt;<span class="hl-tag">interceptors</span>&gt;
        &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"trafficMonitoringInterceptor"</span>/&gt;
    &lt;<span class="hl-tag">/interceptors</span>&gt;
&lt;<span class="hl-tag">/channel</span>&gt;</pre><p>
        In general, it is a good idea to define the interceptor implementations in a separate location since they
        usually provide common behavior that can be reused across multiple channels.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="channel-wiretap"></a>Wire Tap</h3></div></div></div><p>
		As mentioned above, Spring Integration provides a simple <span class="emphasis"><em>Wire Tap</em></span> interceptor out of
		the box. You can configure a <span class="emphasis"><em>Wire Tap</em></span> on any channel within an 'interceptors' element.
        This is especially useful for debugging, and can be used in conjunction with Spring Integration's logging
		Channel Adapter as follows: </p><pre class="programlisting"> &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"in"</span>&gt;
     &lt;<span class="hl-tag">interceptors</span>&gt;
         &lt;<span class="hl-tag">wire-tap</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"logger"</span>/&gt;
     &lt;<span class="hl-tag">/interceptors</span>&gt;
 &lt;<span class="hl-tag">/channel</span>&gt;

 &lt;<span class="hl-tag">logging-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"logger"</span> <span class="hl-attribute">level</span>=<span class="hl-value">"DEBUG"</span>/&gt;</pre><p>
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
			The 'logging-channel-adapter' also accepts a boolean attribute: <span class="emphasis"><em>'log-full-message'</em></span>.
			That is <span class="emphasis"><em>false</em></span> by default so that only the payload is logged. Setting that to
			<span class="emphasis"><em>true</em></span> enables logging of all headers in addition to the payload.
	    </td></tr></tbody></table></div><p>
      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        If namespace support is enabled, there are also two special channels defined within the context by default:
        <code class="code">errorChannel</code> and <code class="code">nullChannel</code>. The 'nullChannel' acts like <code class="code">/dev/null</code>,
        simply logging any Message sent to it at DEBUG level and returning immediately. Any time you face channel
        resolution errors for a reply that you don't care about, you can set the affected component's 'output-channel'
        to reference 'nullChannel' (the name 'nullChannel' is reserved within the context). The 'errorChannel' is
        used internally for sending error messages, and it can be overridden with a custom configuration. It is
        discussed in greater detail in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#namespace-errorhandler" title="B.4Â Error Handling">Section&nbsp;B.4, âError Handlingâ</a>.
      </p></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="endpoint"></a>4.&nbsp;Message Endpoints</h2></div></div></div><p>
    The first part of this chapter covers some background theory and reveals quite a bit about the underlying API
    that drives Spring Integration's various messaging components. This information can be helpful if you want to
    really understand what's going on behind the scenes. However, if you want to get up and running with the
    simplified namespace-based configuration of the various elements, feel free to skip ahead to
    <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#endpoint-namespace" title="4.4Â Namespace Support">Section&nbsp;4.4, âNamespace Supportâ</a> for now.
  </p><p>
    As mentioned in the overview, Message Endpoints are responsible for connecting the various messaging components to
    channels. Over the next several chapters, you will see a number of different components that consume Messages. Some
    of these are also capable of sending reply Messages. Sending Messages is quite straightforward. As shown above in
    <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel" title="3.Â Message Channels">Chapter&nbsp;3, <i>Message Channels</i></a>, it's easy to <span class="emphasis"><em>send</em></span> a Message to a Message Channel. However,
    receiving is a bit more complicated. The main reason is that there are two types of consumers:
    <a class="ulink" href="http://www.eaipatterns.com/PollingConsumer.html" target="_top">Polling Consumers</a> and
    <a class="ulink" href="http://www.eaipatterns.com/EventDrivenConsumer.html" target="_top">Event Driven Consumers</a>.
  </p><p>
    Of the two, Event Driven Consumers are much simpler. Without any need to manage and schedule a separate poller
    thread, they are essentially just listeners with a callback method. When connecting to one of Spring Integration's
    subscribable Message Channels, this simple option works great. However, when connecting to a buffering, pollable
    Message Channel, some component has to schedule and manage the polling thread(s). Spring Integration provides
    two different endpoint implementations to accommodate these two types of consumers. Therefore, the consumers
    themselves can simply implement the callback interface. When polling is required, the endpoint acts as a
    "container" for the consumer instance. The benefit is similar to that of using a container for hosting
    Message Driven Beans, but since these consumers are simply Spring-managed Objects running within an 
    ApplicationContext, it more closely resembles Spring's own MessageListener containers.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint-handler"></a>4.1&nbsp;Message Handler</h2></div></div></div><p>
      Spring Integration's <code class="interfacename">MessageHandler</code> interface is implemented by many of the
      components within the framework. In other words, this is not part of the public API, and a developer would not
      typically implement <code class="interfacename">MessageHandler</code> directly. Nevertheless, it is used by a Message
      Consumer for actually handling the consumed Messages, and so being aware of this strategy interface does help in
      terms of understanding the overall role of a consumer. The interface is defined as follows:
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MessageHandler {

    <span class="hl-keyword">void</span> handleMessage(Message&lt;?&gt; message);

}</pre><p>
      Despite its simplicity, this provides the foundation for most of the components that will be covered in the
      following chapters (Routers, Transformers, Splitters, Aggregators, Service Activators, etc). Those components
      each perform very different functionality with the Messages they handle, but the requirements for actually
      receiving a Message are the same, and the choice between polling and event-driven behavior is also the same.
      Spring Integration provides two endpoint implementations that "host" these callback-based handlers and allow
      them to be connected to Message Channels.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint-eventdrivenconsumer"></a>4.2&nbsp;Event Driven Consumer</h2></div></div></div><p>
      Because it is the simpler of the two, we will cover the Event Driven Consumer endpoint first. You may recall that
      the <code class="interfacename">SubscribableChannel</code> interface provides a <code class="methodname">subscribe()</code>
      method and that the method accepts a <code class="interfacename">MessageHandler</code> parameter (as shown in
      <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-interfaces-subscribablechannel" title="SubscribableChannel">the section called âSubscribableChannelâ</a>):
      </p><pre class="programlisting">subscribableChannel.subscribe(messageHandler);
</pre><p>
      Since a handler that is subscribed to a channel does not have to actively poll that channel, this is an
      Event Driven Consumer, and the implementation provided by Spring Integration accepts a
      a <code class="interfacename">SubscribableChannel</code> and a <code class="interfacename">MessageHandler</code>:
      </p><pre class="programlisting">SubscribableChannel channel = (SubscribableChannel) context.getBean(<span class="hl-string">"subscribableChannel"</span>);

EventDrivenConsumer consumer = <span class="hl-keyword">new</span> EventDrivenConsumer(channel, exampleHandler);</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint-pollingconsumer"></a>4.3&nbsp;Polling Consumer</h2></div></div></div><p>
      Spring Integration also provides a <code class="classname">PollingConsumer</code>, and it can be instantiated in
      the same way except that the channel must implement <code class="interfacename">PollableChannel</code>:
      </p><pre class="programlisting">PollableChannel channel = (PollableChannel) context.getBean(<span class="hl-string">"pollableChannel"</span>);

PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, exampleHandler);</pre><p>
    </p><p>
      There are many other configuration options for the Polling Consumer. For example, the trigger is a required property:
      </p><pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

consumer.setTrigger(<span class="hl-keyword">new</span> IntervalTrigger(30, TimeUnit.SECONDS));</pre><p>
      Spring Integration currently provides two implementations of the <code class="interfacename">Trigger</code>
      interface: <code class="classname">IntervalTrigger</code> and <code class="classname">CronTrigger</code>. The
      <code class="classname">IntervalTrigger</code> is typically defined with a simple interval (in milliseconds), but
      also supports an 'initialDelay' property and a boolean 'fixedRate' property (the default is false, i.e.
      fixed delay):
      </p><pre class="programlisting">IntervalTrigger trigger = <span class="hl-keyword">new</span> IntervalTrigger(1000);
trigger.setInitialDelay(5000);
trigger.setFixedRate(true);</pre><p>
      The <code class="classname">CronTrigger</code> simply requires a valid cron expression (see the Javadoc for details):
      </p><pre class="programlisting">CronTrigger trigger = <span class="hl-keyword">new</span> CronTrigger(<span class="hl-string">"*/10 * * * * MON-FRI"</span>);</pre><p>
    </p><p>
      In addition to the trigger, several other polling-related configuration properties may be specified:
      </p><pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

consumer.setMaxMessagesPerPoll(10);

consumer.setReceiveTimeout(5000);</pre><p>
    </p><p>
      The 'maxMessagesPerPoll' property specifies the maximum number of messages to receive within a given poll
      operation. This means that the poller will continue calling receive() <span class="emphasis"><em>without waiting</em></span>
      until either <code class="code">null</code> is returned or that max is reached. For example, if a poller has a 10 second
      interval trigger and a 'maxMessagesPerPoll' setting of 25, and it is polling a channel that has 100 messages
      in its queue, all 100 messages can be retrieved within 40 seconds. It grabs 25, waits 10 seconds, grabs the
      next 25, and so on.
    </p><p>
      The 'receiveTimeout' property specifies the amount of time the poller should wait if no messages are
      available when it invokes the receive operation. For example, consider two options that seem similar on
      the surface but are actually quite different: the first has an interval trigger of 5 seconds and a receive
      timeout of 50 milliseconds while the second has an interval trigger of 50 milliseconds and a receive timeout
      of 5 seconds. The first one may receive a message up to 4950 milliseconds later than it arrived on the channel
      (if that message arrived immediately after one of its poll calls returned). On the other hand, the second
      configuration will never miss a message by more than 50 milliseconds. The difference is that the second
      option requires a thread to wait, but as a result it is able to respond much more quickly to arriving messages.
      This technique, known as "long polling", can be used to emulate event-driven behavior on a polled source.
    </p><p>
      A Polling Consumer may also delegate to a Spring <code class="interfacename">TaskExecutor</code>, and it can
      be configured to participate in Spring-managed transactions. The following example shows the configuration of both:
      </p><pre class="programlisting">PollingConsumer consumer = <span class="hl-keyword">new</span> PollingConsumer(channel, handler);

TaskExecutor taskExecutor = (TaskExecutor) context.getBean(<span class="hl-string">"exampleExecutor"</span>);
consumer.setTaskExecutor(taskExecutor);

PlatformTransactionManager txManager = (PlatformTransationManager) context.getBean(<span class="hl-string">"exampleTxManager"</span>);
consumer.setTransactionManager(txManager);</pre><p>
      The examples above show dependency lookups, but keep in mind that these consumers will most often be configured
      as Spring <span class="emphasis"><em>bean definitions</em></span>. In fact, Spring Integration also provides a
      <code class="interfacename">FactoryBean</code> that creates the appropriate consumer type based on the type of
      channel, and there is full XML namespace support to even further hide those details. The namespace-based
      configuration will be featured as each component type is introduced.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
		Many of the <code class="interfacename">MessageHandler</code> implementations are also capable of generating reply
        Messages. As mentioned above, sending Messages is trivial when compared to the Message reception. Nevertheless,
        <span class="emphasis"><em>when</em></span> and <span class="emphasis"><em>how many</em></span> reply Messages are sent depends on the handler
        type. For example, an <span class="emphasis"><em>Aggregator</em></span> waits for a number of Messages to arrive and is often
        configured as a downstream consumer for a <span class="emphasis"><em>Splitter</em></span> which may generate multiple
        replies for each Message it handles. When using the namespace configuration, you do not strictly need to know
        all of the details, but it still might be worth knowing that several of these components share a common base
        class, the <code class="classname">AbstractReplyProducingMessageHandler</code>, and it provides a
        <code class="methodname">setOutputChannel(..)</code> method.
      </td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="endpoint-namespace"></a>4.4&nbsp;Namespace Support</h2></div></div></div><p>
      Throughout the reference manual, you will see specific configuration examples for endpoint elements, such as
      router, transformer, service-activator, and so on. Most of these will support an "input-channel" attribute and
      many will support an "output-channel" attribute. After being parsed, these endpoint elements produce an instance
      of either the <code class="classname">PollingConsumer</code> or the
      <code class="classname">EventDrivenConsumer</code> depending on the type of the "input-channel" that is
      referenced: <code class="interfacename">PollableChannel</code> or <code class="interfacename">SubscribableChannel</code>
      respectively. When the channel is pollable, then the polling behavior is determined based on the endpoint
      element's "poller" sub-element. For example, a simple interval-based poller with a 1-second interval would be
      configured like this: </p><pre class="programlisting"> &lt;<span class="hl-tag">transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
              <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
              <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>&gt;
     &lt;<span class="hl-tag">poller</span>&gt;
         &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"1000"</span>/&gt;
     &lt;<span class="hl-tag">/poller</span>&gt;
&lt;<span class="hl-tag">/transformer</span>&gt;</pre><p>
      For a poller based on a Cron expression, use the "cron-trigger" child element instead:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
              <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
              <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>&gt;
     &lt;<span class="hl-tag">poller</span>&gt;
         &lt;<span class="hl-tag">cron-trigger</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"*/10 * * * * MON-FRI"</span>/&gt;
     &lt;<span class="hl-tag">/poller</span>&gt;
 &lt;<span class="hl-tag">/transformer</span>&gt;</pre><p>
    </p><p>
      If the input channel is a <code class="interfacename">PollableChannel</code>, then the poller configuration is
      required. Specifically, as mentioned above, the 'trigger' is a required property of the PollingConsumer class.
      Therefore, if you omit the "poller" sub-element for a Polling Consumer endpoint's configuration, an Exception
      may be thrown. However, it is also possible to create top-level pollers in which case only a "ref" is required:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">id</span>=<span class="hl-value">"weekdayPoller"</span>&gt;
     &lt;<span class="hl-tag">cron-trigger</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"*/10 * * * * MON-FRI"</span>/&gt;
 &lt;<span class="hl-tag">/poller</span>&gt;

 &lt;<span class="hl-tag">transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
              <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
              <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>&gt;
    &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"weekdayPoller"</span>/&gt;
 &lt;<span class="hl-tag">/transformer</span>&gt;</pre><p>
      In fact, to simplify the configuration, you can define a global default poller. A single top-level poller within
      an ApplicationContext may have the <code class="code">default</code> attribute with a value of "true". In that case, any
      endpoint with a PollableChannel for its input-channel that is defined within the same ApplicationContext and has
      no explicitly configured 'poller' sub-element will use that default.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">id</span>=<span class="hl-value">"defaultPoller"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"5"</span>&gt;
     &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"3"</span> <span class="hl-attribute">time-unit</span>=<span class="hl-value">"SECONDS"</span>/&gt;
 &lt;<span class="hl-tag">/poller</span>&gt;

 &lt;<span class="hl-comment">!-- No &lt;poller/&gt; sub-element is necessary since there is a default --</span>&gt;
 &lt;<span class="hl-tag">transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span>
              <span class="hl-attribute">ref</span>=<span class="hl-value">"transformer"</span>
              <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>/&gt;</pre><p>
    </p><p>
      Spring Integration also provides transaction support for the pollers so that each receive-and-forward
      operation can be performed as an atomic unit-of-work. To configure transactions for a poller, simply add the
      &lt;transactional/&gt; sub-element. The attributes for this element should be familiar to anyone who has
      experience with Spring's Transaction management:
      </p><pre class="programlisting">&lt;<span class="hl-tag">poller</span>&gt;
    &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"1000"</span>/&gt;
    &lt;<span class="hl-tag">transactional</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"txManager"</span>
                   <span class="hl-attribute">propagation</span>=<span class="hl-value">"REQUIRED"</span>
                   <span class="hl-attribute">isolation</span>=<span class="hl-value">"REPEATABLE_READ"</span>
                   <span class="hl-attribute">timeout</span>=<span class="hl-value">"10000"</span>
                   <span class="hl-attribute">read-only</span>=<span class="hl-value">"false"</span>/&gt;
&lt;<span class="hl-tag">/poller</span>&gt;</pre><p> 
    </p><p>
      The polling threads may be executed by any instance of Spring's <code class="interfacename">TaskExecutor</code>
      abstraction. This enables concurrency for an endpoint or group of endpoints. As a convenience, there is also
      namespace support for creating a simple thread pool executor. The &lt;thread-pool-task-executor/&gt; element
      defines attributes for common concurrency settings such as core-size, max-size, and queue-capacity. Configuring
      a thread-pooling executor can make a substantial difference in how the endpoint performs under load. These
      settings are available per-endpoint since the performance of an endpoint is one of the major factors to consider
      (the other major factor being the expected volume on the channel to which the endpoint subscribes). To enable
      concurrency for a polling endpoint that is configured with the XML namespace support, provide the 'task-executor'
      reference on its &lt;poller/&gt; element and then provide one or more of the properties shown below:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"pool"</span>/&gt;
     &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"5"</span> <span class="hl-attribute">time-unit</span>=<span class="hl-value">"SECONDS"</span>/&gt;
 &lt;<span class="hl-tag">/poller</span>&gt;

 &lt;<span class="hl-tag">thread-pool-task-executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pool"</span>
                            <span class="hl-attribute">core-size</span>=<span class="hl-value">"5"</span>
                            <span class="hl-attribute">max-size</span>=<span class="hl-value">"25"</span>
                            <span class="hl-attribute">queue-capacity</span>=<span class="hl-value">"20"</span>
                            <span class="hl-attribute">keep-alive-seconds</span>=<span class="hl-value">"120"</span>/&gt;</pre><p>
      If no 'task-executor' is provided, the consumer's handler will be invoked in the caller's thread. Note that the
      "caller" is usually the default <code class="interfacename">TaskScheduler</code>
      (see <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#namespace-taskscheduler" title="B.3Â Configuring the Task Scheduler">Section&nbsp;B.3, âConfiguring the Task Schedulerâ</a>). Also, keep in mind that the 'task-executor' attribute can
      provide a reference to any implementation of Spring's <code class="interfacename">TaskExecutor</code> interface by
      specifying the bean name. The thread pool element is simply provided for convenience.
    </p><p>
    	As mentioned in the background section for Polling Consumers above, you can also configure a Polling Consumer
        in such a way as to emulate event-driven behavior. With a long receive-timeout and a short interval-trigger,
        you can ensure a very timely reaction to arriving messages even on a polled message source. Note that this
        will only apply to sources that have a blocking wait call with a timeout. For example, the File poller does
        not block, each receive() call returns immediately and either contains new files or not. Therefore, even if
        a poller contains a long receive-timeout, that value would never be usable in such a scenario. On the other
        hand when using Spring Integration's own queue-based channels, the timeout value does have a chance to
        participate. The following example demonstrates how a Polling Consumer will receive Messages nearly
        instantaneously.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"someQueueChannel"</span>
        <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>&gt;  
     &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">receive-timeout</span>=<span class="hl-value">"30000"</span>&gt;
         &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"10"</span>/&gt;
     &lt;<span class="hl-tag">/poller</span>&gt;
 &lt;<span class="hl-tag">/service-activator</span>&gt;</pre><p>
      Using this approach does not carry much overhead since internally it is nothing more then a timed-wait thread
      which does not require nearly as much CPU resource usage as a thrashing, infinite while loop for example.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="service-activator"></a>5.&nbsp;Service Activator</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-activator-introduction"></a>5.1&nbsp;Introduction</h2></div></div></div><p>
      The Service Activator is the endpoint type for connecting any Spring-managed Object to an input channel so that
      it may play the role of a service. If the service produces output, it may also be connected to an output channel.
      Alternatively, an output producing service may be located at the end of a processing pipeline or message flow in
      which case, the inbound Message's "replyChannel" header can be used. This is the default behavior if no output
      channel is defined, and as with most of the configuration options you'll see here, the same behavior actually
      applies for most of the other components we have seen.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-activator-namespace"></a>5.2&nbsp;The &lt;service-activator/&gt; Element</h2></div></div></div><p>
      To create a Service Activator, use the 'service-activator' element with the 'input-channel' and 'ref' attributes:
      </p><pre class="programlisting">&lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"exampleHandler"</span>/&gt;</pre><p>
    </p><p>
      The configuration above assumes that "exampleHandler" either contains a single method annotated with the
      @ServiceActivator annotation or that it contains only one public method at all. To delegate to an explicitly
      defined method of any object, simply add the "method" attribute.
      </p><pre class="programlisting">&lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span>/&gt;</pre><p>
    </p><p>
      In either case, when the service method returns a non-null value, the endpoint will attempt to send the reply
      message to an appropriate reply channel. To determine the reply channel, it will first check if an
      "output-channel" was provided in the endpoint configuration:
      </p><pre class="programlisting">&lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"exampleChannel"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"replyChannel"</span>
                   <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span>/&gt;</pre><p>
      If no "output-channel" is available, it will then check the Message's <code class="literal">REPLY_CHANNEL</code> header
      value. If that value is available, it will then check its type. If it is a
      <code class="interfacename">MessageChannel</code>, the reply message will be sent to that channel. If it is a
      <code class="classname">String</code>, then the endpoint will attempt to resolve the channel name to a channel instance.
      If the channel cannot be resolved, then a <code class="classname">ChannelResolutionException</code> will be thrown.
    </p><p>
      The argument in the service method could be either a Message or an arbitrary type. If the latter, then it will
      be assumed that it is a Message payload, which will be extracted from the message and injected into such service
      method. This is generally the recommended approach as it follows and promotes a POJO model when working with Spring
      Integration. Arguments may also have @Header or @Headers annotations as described in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#annotations" title="B.5Â Annotation Support">Section&nbsp;B.5, âAnnotation Supportâ</a>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
       Since v1.0.3 of Spring Integration, the service method is not required to have an argument at all, which means you
       can now implement event-style Service Activators, where all you care about is an invocation of the service method,
       not worrying about the contents of the message. Think of it as a NULL JMS message. An example use-case for such an
       implementation could be a simple counter/monitor of messages deposited on the input channel.
    </td></tr></tbody></table></div><p>
      Using a "ref" attribute is generally recommended if the custom Service Activator handler implementation can be reused
      in other <code class="code">&lt;service-activator&gt;</code> definitions. However if the custom Service Activator handler implementation
      should be scoped to a single definition of the <code class="code">&lt;service-activator&gt;</code>, you can use an inner bean definition:
</p><pre class="programlisting">&lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleServiceActivator"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span> 
						<span class="hl-attribute">output-channel</span> = <span class="hl-value">"outChannel"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"foo"</span>&gt;
		&lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.ExampleServiceActivator"</span>/&gt;
&lt;<span class="hl-tag">/service-activator</span>&gt;</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
    Using both the "ref" attribute and an inner handler definition in the same <code class="code">&lt;service-activator&gt;</code>
    configuration is not allowed, as it creates an ambiguous condition and will result in an Exception being thrown.
    </p></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="channel-adapter"></a>6.&nbsp;Channel Adapter</h2></div></div></div><p>
    A Channel Adapter is a Message Endpoint that enables connecting a single sender or receiver to a Message Channel.
    Spring Integration provides a number of adapters out of the box to support various transports, such as JMS, File,
    HTTP, Web Services, and Mail. Those will be discussed in upcoming chapters of this reference guide. However, this
    chapter focuses on the simple but flexible Method-invoking Channel Adapter support. There are both inbound and
    outbound adapters, and each may be configured with XML elements provided in the core namespace.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="channel-adapter-namespace-inbound"></a>6.1&nbsp;The &lt;inbound-channel-adapter&gt; element</h2></div></div></div><p>
      An "inbound-channel-adapter" element can invoke any method on a Spring-managed Object and send a non-null return
      value to a <code class="interfacename">MessageChannel</code> after converting it to a <code class="classname">Message</code>.
      When the adapter's subscription is activated, a poller will attempt to receive messages from the source. The
      poller will be scheduled with the <code class="interfacename">TaskScheduler</code> according to the provided
      configuration. To configure the polling interval or cron expression for an individual channel-adapter,
      provide a 'poller' element with either an 'interval-trigger' (in milliseconds) or 'cron-trigger'
      sub-element.
      </p><pre class="programlisting">&lt;<span class="hl-tag">inbound-channel-adapter</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"source1"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"method1"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"channel1"</span>&gt;
    &lt;<span class="hl-tag">poller</span>&gt;
        &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"5000"</span>/&gt;
    &lt;<span class="hl-tag">/poller</span>&gt;
&lt;<span class="hl-tag">/inbound-channel-adapter</span>&gt;

&lt;<span class="hl-tag">inbound-channel-adapter</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"source2"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"method2"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"channel2"</span>&gt;
    &lt;<span class="hl-tag">poller</span>&gt;
        &lt;<span class="hl-tag">cron-trigger</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"30 * 9-17 * * MON-FRI"</span>/&gt;
    &lt;<span class="hl-tag">/poller</span>&gt;
&lt;<span class="hl-tag">/channel-adapter</span>&gt;</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        If no poller is provided, then a single default poller must be registered within the context.
        See <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#endpoint-namespace" title="4.4Â Namespace Support">Section&nbsp;4.4, âNamespace Supportâ</a> for more detail.
      </p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="channel-adapter-namespace-outbound"></a>6.2&nbsp;The &lt;outbound-channel-adapter/&gt; element</h2></div></div></div><p>
      An "outbound-channel-adapter" element can also connect a <code class="interfacename">MessageChannel</code> to any
      method that should be invoked with the payload of Messages sent to that channel.
      </p><pre class="programlisting">&lt;<span class="hl-tag">outbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"channel1"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"target1"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"method1"</span>/&gt;</pre><p>
      If the channel being adapted is a <code class="interfacename">PollableChannel</code>, provide a poller sub-element:
        </p><pre class="programlisting">&lt;<span class="hl-tag">outbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"channel2"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"target2"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"method2"</span>&gt;
    &lt;<span class="hl-tag">poller</span>&gt;
        &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"3000"</span>/&gt;
    &lt;<span class="hl-tag">/poller</span>&gt;
&lt;<span class="hl-tag">/outbound-channel-adapter</span>&gt;</pre><p>
    </p><p>
      Any Channel Adapter can be created without a "channel" reference in which case it will implicitly create an
      instance of <code class="classname">DirectChannel</code>. The created channel's name will match the "id" attribute
      of the &lt;inbound-channel-adapter/&gt; or &lt;outbound-channel-adapter element. Therefore, if the "channel"
      is not provided, the "id" is required.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="router"></a>7.&nbsp;Router</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="router-implementations"></a>7.1&nbsp;Router Implementations</h2></div></div></div><p>
      Since content-based routing often requires some domain-specific logic, most use-cases will require
      Spring Integration's options for delegating to POJOs using the XML namespace support and/or Annotations.
      Both of these are discussed below, but first we present a couple implementations that are available
      out-of-the-box since they fulfill generic, but common, requirements.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="router-implementations-payloadtyperouter"></a>PayloadTypeRouter</h3></div></div></div><p>
        A <code class="classname">PayloadTypeRouter</code> will send Messages to the channel as defined by payload-type
        mappings.
        </p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"payloadTypeRouter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.router.PayloadTypeRouter"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"payloadTypeChannelMap"</span>&gt;
        &lt;<span class="hl-tag">map</span>&gt;
            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"stringChannel"</span>/&gt;
            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"java.lang.Integer"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"integerChannel"</span>/&gt;
        &lt;<span class="hl-tag">/map</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
      </p><p>
      Configuration of <code class="classname">PayloadTypeRouter</code> is also supported via the namespace provided by Spring Integration (see <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#configuration-namespace" title="B.2Â Namespace Support">Section&nbsp;B.2, âNamespace Supportâ</a>),
      which essentially simplifies configuration by combining <code class="code">&lt;router/&gt;</code> configuration and its corresponding implementation defined using <code class="code">&lt;bean/&gt;</code> element 
      into a single and more concise configuration element.
      The example below demonstrates <code class="classname">PayloadTypeRouter</code> configuration which is equivalent to the one above using Spring Integration's namespace support:
      </p><p>
      </p><pre class="programlisting">&lt;<span class="hl-tag">payload-type-router</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"routingChannel"</span>&gt;
	&lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"stringChannel"</span> /&gt;
	&lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.Integer"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"integerChannel"</span> /&gt;
&lt;<span class="hl-tag">/payload-type-router</span>&gt;</pre><p>
	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="router-implementations-headervaluerouter"></a>HeaderValueRouter</h3></div></div></div><p>
        A <code class="classname">HeaderValueRouter</code> will send Messages to the channel based on the individual header value mappings.
        When <code class="code">HeaderValueRouter</code> is created it is initialized with the <span class="emphasis"><em>name</em></span> of the header to be evaluated, using <code class="code">constructor-arg</code>.
        The <span class="emphasis"><em>value</em></span> of the header could be one of two things:</p><p>
        1. Arbitrary value
     </p><p>
        2. Channel name
     </p><p>
        If arbitrary value, then a <code class="code">channelResolver</code> should be provided to map <span class="emphasis"><em>header values</em></span> to <span class="emphasis"><em>channel names</em></span>.
		The example below uses <code class="code">MapBasedChannelResolver</code> to set up a map of header values to channel names.
</p><pre class="programlisting"> &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myHeaderValueRouter"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.router.HeaderValueRouter"</span>&gt;
  &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"someHeaderName"</span> /&gt; 
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channelResolver"</span>&gt;
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.channel.MapBasedChannelResolver"</span>&gt;
      &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channelMap"</span>&gt;
        &lt;<span class="hl-tag">map</span>&gt;
          &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"someHeaderValue"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"channelA"</span> /&gt;
          &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"someOtherHeaderValue"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"channelB"</span> /&gt;
        &lt;<span class="hl-tag">/map</span>&gt;
      &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
</pre><p>
        If <code class="code">channelResolver</code> is not specified, then the <span class="emphasis"><em>header value</em></span> will be treated as a <span class="emphasis"><em>channel name</em></span> 
        making configuration much simpler, where no <code class="code">channelResolver</code> needs to be specified.
</p><pre class="programlisting"> 
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myHeaderValueRouter"</span>
	<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.router.HeaderValueRouter"</span>&gt;
	&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"someHeaderName"</span> /&gt; 
&lt;<span class="hl-tag">/bean</span>&gt;
</pre><p> 
      </p><p>
      Similar to the <code class="classname">PayloadTypeRouter</code>, configuration of <code class="classname">HeaderValueRouter</code> is also supported via namespace support provided by Spring Integration (see <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#configuration-namespace" title="B.2Â Namespace Support">Section&nbsp;B.2, âNamespace Supportâ</a>).
      The example below demonstrates two types of namespace-based configuration of <code class="classname">HeaderValueRouter</code> which are equivalent to the ones above using Spring Integration namespace support:
      </p><p>1. Configuration where mapping of header values to channels is required</p><p>
      </p><pre class="programlisting">&lt;<span class="hl-tag">header-value-router</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"routingChannel"</span> <span class="hl-attribute">header-name</span>=<span class="hl-value">"testHeader"</span>&gt;
	&lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">value</span>=<span class="hl-value">"someHeaderValue"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"channelA"</span> /&gt;
	&lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">value</span>=<span class="hl-value">"someOtherHeaderValue"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"channelB"</span> /&gt;
&lt;<span class="hl-tag">/header-value-router</span>&gt;</pre><p>
	</p><p>2. Configuration where mapping of header values is not required if header values themselves represent the channel names</p><p>
      </p><pre class="programlisting">&lt;<span class="hl-tag">header-value-router</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"routingChannel"</span> <span class="hl-attribute">header-name</span>=<span class="hl-value">"testHeader"</span>/&gt;</pre><p>
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      The two router implementations shown above share some common properties, such as "defaultOutputChannel" and "resolutionRequired".
      If "resolutionRequired" is set to "true", and the router is unable to determine a target channel (e.g. there is
      no matching payload for a PayloadTypeRouter and no "defaultOutputChannel" has been specified), then an Exception
      will be thrown.
    </td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="router-implementations-recipientlistrouter"></a>RecipientListRouter</h3></div></div></div><p>
        A <code class="classname">RecipientListRouter</code> will send each received Message to a statically-defined
        list of Message Channels:
        </p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"recipientListRouter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.router.RecipientListRouter"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channels"</span>&gt;
        &lt;<span class="hl-tag">list</span>&gt;
            &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"channel1"</span>/&gt;
            &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"channel2"</span>/&gt;
            &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"channel3"</span>/&gt;
        &lt;<span class="hl-tag">/list</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
      </p></div><p>
      Configuration for <code class="classname">RecipientListRouter</code> is also supported via namespace support provided by Spring Integration (see <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#configuration-namespace" title="B.2Â Namespace Support">Section&nbsp;B.2, âNamespace Supportâ</a>).
      The example below demonstrates namespace-based configuration of <code class="classname">RecipientListRouter</code> and all the supported attributes using Spring Integration namespace support:
      </p><p>
      </p><pre class="programlisting">&lt;<span class="hl-tag">recipient-list-router</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customRouter"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"routingChannel"</span>
				<span class="hl-attribute">timeout</span>=<span class="hl-value">"1234"</span>
				<span class="hl-attribute">ignore-send-failures</span>=<span class="hl-value">"true"</span>
				<span class="hl-attribute">apply-sequence</span>=<span class="hl-value">"true"</span>&gt;
	&lt;<span class="hl-tag">recipient</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"channel1"</span>/&gt;
	&lt;<span class="hl-tag">recipient</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"channel2"</span>/&gt;
&lt;<span class="hl-tag">/recipient-list-router</span>&gt;</pre><p>
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      The 'apply-sequence' flag here has the same affect as it does for a publish-subscribe-channel,
      and like publish-subscribe-channel it is disabled by default on the recipient-list-router. Refer to
      <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-configuration-pubsubchannel" title="PublishSubscribeChannel Configuration">the section called âPublishSubscribeChannel Configurationâ</a> for more information.
	</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="router-namespace"></a>7.2&nbsp;The &lt;router&gt; element</h2></div></div></div><p>
	  The "router" element provides a simple way to connect a router to an input channel, and also accepts the
      optional default output channel. The "ref" may provide the bean name of a custom Router implementation
      (extending AbstractMessageRouter):
      </p><pre class="programlisting">&lt;<span class="hl-tag">router</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"payloadTypeRouter"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input1"</span> <span class="hl-attribute">default-output-channel</span>=<span class="hl-value">"defaultOutput1"</span>/&gt;

&lt;<span class="hl-tag">router</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"recipientListRouter"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input2"</span> <span class="hl-attribute">default-output-channel</span>=<span class="hl-value">"defaultOutput2"</span>/&gt;

&lt;<span class="hl-tag">router</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customRouter"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input3"</span> <span class="hl-attribute">default-output-channel</span>=<span class="hl-value">"defaultOutput3"</span>/&gt;

&lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"customRouterBean class="</span><span class="hl-attribute">org.foo.MyCustomRouter"/&gt;</span></pre><p>

      Alternatively, the "ref" may point to a simple Object that contains the @Router annotation (see below), or the
      "ref" may be combined with an explicit "method" name. When specifying a "method", the same behavior applies as
      described in the @Router annotation section below.
      </p><pre class="programlisting">&lt;<span class="hl-tag">router</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"somePojo"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span>/&gt;</pre><p>
      Using a "ref" attribute is generally recommended if the custom router implementation can be reused in other
      <code class="code">&lt;router&gt;</code> definitions. However if the custom router implementation should be scoped to a
      concrete definition of the <code class="code">&lt;router&gt;</code>, you can provide an inner bean definition:
</p><pre class="programlisting">&lt;<span class="hl-tag">router</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input3"</span> <span class="hl-attribute">default-output-channel</span>=<span class="hl-value">"defaultOutput3"</span>&gt;
	&lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.MyCustomRouter"</span>/&gt;
&lt;<span class="hl-tag">/router</span>&gt;</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        Using both the "ref" attribute and an inner handler definition in the same <code class="code">&lt;router&gt;</code> configuration
        is not allowed, as it creates an ambiguous condition and will result in an Exception being thrown.
      </p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="router-annotation"></a>7.3&nbsp;The @Router Annotation</h2></div></div></div><p>
      When using the <code class="interfacename">@Router</code> annotation, the annotated method can return either the
      <code class="interfacename">MessageChannel</code> or <code class="classname">String</code> type. In the case of the latter,
      the endpoint will resolve the channel name as it does for the default output. Additionally, the method can return
      either a single value or a collection. When a collection is returned, the reply message will be sent to multiple
      channels. To summarize, the following method signatures are all valid.
      </p><pre class="programlisting">@Router
<span class="hl-keyword">public</span> MessageChannel route(Message message) {...}

@Router
<span class="hl-keyword">public</span> List&lt;MessageChannel&gt; route(Message message) {...}

@Router
<span class="hl-keyword">public</span> String route(Foo payload) {...}

@Router
<span class="hl-keyword">public</span> List&lt;String&gt; route(Foo payload) {...}</pre><p>
    </p><p>
      In addition to payload-based routing, a common requirement is to route based on metadata available within the
      message header as either a property or attribute. Rather than requiring use of the
      <code class="interfacename">Message</code> type as the method parameter, the <code class="interfacename">@Router</code>
      annotation may also use the @Header parameter annotation that is documented in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#annotations" title="B.5Â Annotation Support">Section&nbsp;B.5, âAnnotation Supportâ</a>.
      </p><pre class="programlisting">@Router
<span class="hl-keyword">public</span> List&lt;String&gt; route(@Header(<span class="hl-string">"orderStatus"</span>) OrderStatus status)</pre><p>
    </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
    For routing of XML-based Messages, including XPath support, see <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xml" title="26.Â Dealing with XML Payloads">Chapter&nbsp;26, <i>Dealing with XML Payloads</i></a>.
  </td></tr></tbody></table></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="filter"></a>8.&nbsp;Filter</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="filter-introduction"></a>8.1&nbsp;Introduction</h2></div></div></div><p>
      Message Filters are used to decide whether a Message should be passed along or dropped based on some criteria
      such as a Message Header value or even content within the Message itself. Therefore, a Message Filter is similar
      to a router, except that for each Message received from the filter's input channel, that same Message may or may
      not be sent to the filter's output channel. Unlike the router, it makes no decision regarding
      <span class="emphasis"><em>which</em></span> Message Channel to send to but only decides <span class="emphasis"><em>whether</em></span> to send.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        As you will see momentarily, the Filter does also support a discard channel, so in certain cases it
        <span class="emphasis"><em>can</em></span> play the role of a very simple router (or "switch") based on a boolean condition.
      </td></tr></tbody></table></div><p>
    </p><p>
      In Spring Integration, a Message Filter may be configured as a Message Endpoint that delegates to some
      implementation of the <code class="interfacename">MessageSelector</code> interface. That interface is itself quite
      simple: </p><pre class="programlisting"> <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> MessageSelector {

     <span class="hl-keyword">boolean</span> accept(Message&lt;?&gt; message);

 }</pre><p>
      The <code class="classname">MessageFilter</code> constructor accepts a selector instance:
      </p><pre class="programlisting"> MessageFilter filter = <span class="hl-keyword">new</span> MessageFilter(someSelector);</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="filter-namespace"></a>8.2&nbsp;The &lt;filter&gt; Element</h2></div></div></div><p>
	  The &lt;filter&gt; element is used to create a Message-selecting endpoint. In addition to "input-channel"
      and "output-channel" attributes, it requires a "ref". The "ref" may point to a MessageSelector implementation:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"selector"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>/&gt;

 &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"selector"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"example.MessageSelectorImpl"</span>/&gt;</pre><p>
    </p><p>
      Alternatively, the "method" attribute can be added at which point the "ref" may refer to any object.
      The referenced method may expect either the <code class="interfacename">Message</code> type or the payload type of
      inbound Messages. The return value of the method must be a boolean value. Any time the method returns 'true',
      the Message <span class="emphasis"><em>will</em></span> be passed along to the output-channel.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
         <span class="hl-attribute">ref</span>=<span class="hl-value">"exampleObject"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someBooleanReturningMethod"</span>/&gt;

 &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"exampleObject"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"example.SomeObject"</span>/&gt;</pre><p>
    </p><p>
      If the selector or adapted POJO method returns <code class="code">false</code>, there are a few settings that control the
      fate of the rejected Message. By default (if configured like the example above), the rejected Messages will
      be silently dropped. If rejection should instead indicate an error condition, then set the
      'throw-exception-on-rejection' flag to <code class="code">true</code>:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"selector"</span>
      <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span> <span class="hl-attribute">throw-exception-on-rejection</span>=<span class="hl-value">"true"</span>/&gt; </pre><p>
	  If you want the rejected messages to go to a specific channel, provide that reference as the 'discard-channel':
      </p><pre class="programlisting"> &lt;<span class="hl-tag">filter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"selector"</span>
      <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span> <span class="hl-attribute">discard-channel</span>=<span class="hl-value">"rejectedMessages"</span>/&gt; </pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      A common usage for Message Filters is in conjunction with a Publish Subscribe Channel. Many filter endpoints may
      be subscribed to the same channel, and they decide whether or not to pass the Message for the next endpoint which
      could be any of the supported types (e.g. Service Activator). This provides a <span class="emphasis"><em>reactive</em></span>
      alternative to the more <span class="emphasis"><em>proactive</em></span> approach of using a Message Router with a single
      Point-to-Point input channel and multiple output channels.
    </td></tr></tbody></table></div><p>
      Using a "ref" attribute is generally recommended if the custom filter implementation can be reused in other
      <code class="code">&lt;filter&gt;</code> definitions. However if the custom filter implementation should be scoped to a
      single <code class="code">&lt;filter&gt;</code> element, provide an inner bean definition:
</p><pre class="programlisting">&lt;<span class="hl-tag">filter</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"outChannel"</span>&gt;
	&lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.MyCustomFilter"</span>/&gt;
&lt;<span class="hl-tag">/filter</span>&gt;</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        Using both the "ref" attribute and an inner handler definition in the same <code class="code">&lt;filter&gt;</code> configuration
        is not allowed, as it creates an ambiguous condition, and it will therefore result in an Exception being thrown.
      </p></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transformer"></a>9.&nbsp;Transformer</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformer-introduction"></a>9.1&nbsp;Introduction</h2></div></div></div><p>
      Message Transformers play a very important role in enabling the loose-coupling of Message Producers and Message
      Consumers. Rather than requiring every Message-producing component to know what type is expected by the next
      consumer, Transformers can be added between those components. Generic transformers, such as one that converts a
      String to an XML Document, are also highly reusable.
    </p><p>
      For some systems, it may be best to provide a
      <a class="ulink" href="http://www.eaipatterns.com/CanonicalDataModel.html" target="_top">Canonical Data Model</a>, but Spring
      Integration's general philosophy is not to require any particular format. Rather, for maximum flexibility, Spring
      Integration aims to provide the simplest possible model for extension. As with the other endpoint types, the use
      of declarative configuration in XML and/or Annotations enables simple POJOs to be adapted for the role of Message
      Transformers. These configuration options will be described below.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        For the same reason of maximizing flexibility, Spring does not require XML-based Message payloads.
        Nevertheless, the framework does provide some convenient Transformers for dealing with XML-based payloads if
        that is indeed the right choice for your application. For more information on those transformers, see
        <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#xml" title="26.Â Dealing with XML Payloads">Chapter&nbsp;26, <i>Dealing with XML Payloads</i></a>.
      </td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformer-namespace"></a>9.2&nbsp;The &lt;transformer&gt; Element</h2></div></div></div><p>
	  The &lt;transformer&gt; element is used to create a Message-transforming endpoint. In addition to "input-channel"
      and "output-channel" attributes, it requires a "ref". The "ref" may either point to an Object that contains the
      @Transformer annotation on a single method (see below) or it may be combined with an explicit method name value
      provided via the "method" attribute.
      </p><pre class="programlisting">&lt;<span class="hl-tag">transformer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"testTransformer"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"testTransformerBean"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span> 
					   <span class="hl-attribute">method</span>=<span class="hl-value">"transform"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"outChannel"</span>/&gt;
&lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"testTransformerBean"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.TestTransformer"</span> /&gt;</pre><p>
    </p><p>
      Using a "ref" attribute is generally recommended if the custom transformer handler implementation can be reused in
      other <code class="code">&lt;transformer&gt;</code> definitions. However if the custom transformer handler implementation should
      be scoped to a single definition of the <code class="code">&lt;transformer&gt;</code>, you can define an inner bean definition:
</p><pre class="programlisting">&lt;<span class="hl-tag">transformer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"testTransformer"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"transform"</span>
								<span class="hl-attribute">output-channel</span>=<span class="hl-value">"outChannel"</span>&gt;
	&lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.TestTransformer"</span>/&gt;
&lt;<span class="hl-tag">/transformer</span>&gt;</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        Using both the "ref" attribute and an inner handler definition in the same <code class="code">&lt;transformer&gt;</code>
        configuration is not allowed, as it creates an ambiguous condition and will result in an Exception being thrown.
      </p></td></tr></tbody></table></div><p>
      The method that is used for transformation may expect either the <code class="interfacename">Message</code> type or
      the payload type of inbound Messages. It may also accept Message header values either individually or as a full
      map by using the @Header and @Headers parameter annotations respectively. The return value of the method can be
      any type. If the return value is itself a <code class="interfacename">Message</code>, that will be passed along to
      the transformer's output channel. If the return type is a Map, and the original Message payload was
      <span class="emphasis"><em>not</em></span> a Map, the entries in that Map will be added to the Message headers of the original
      Message (the keys must be Strings). If the return value is <span class="emphasis"><em>null</em></span>, then no reply Message will
      be sent (effectively the same behavior as a Message Filter returning false). Otherwise, the return value will be
      sent as the payload of an outbound reply Message.
    </p><p>
		There are a also a few Transformer implementations available out of the box. Because, it is fairly common
		to use the <code class="methodname">toString()</code> representation of an Object, Spring Integration provides an
		<code class="classname">ObjectToStringTransformer</code> whose output is a Message with a String payload. That String
		is the result of invoking the toString operation on the inbound Message's payload.
		</p><pre class="programlisting"> &lt;<span class="hl-tag">object-to-string-transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span>/&gt;</pre><p>
		A potential example for this would be sending some arbitrary object to the 'outbound-channel-adapter' in the
		<span class="emphasis"><em>file</em></span> namespace. Whereas that Channel Adapter only supports String, byte-array, or
		<code class="classname">java.io.File</code> payloads by default, adding this transformer immediately before the
		adapter will handle the necessary conversion. Of course, that works fine as long as the result of the
		<code class="methodname">toString()</code> call is what you want to be written to the File. Otherwise, you can
		just provide a custom POJO-based Transformer via the generic 'transformer' element shown previously.
		</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
			When debugging, this transformer is not typically necessary since the 'logging-channel-adapter' is capable
			of logging the Message payload. Refer to <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-wiretap" title="Wire Tap">the section called âWire Tapâ</a> for more detail.
		</td></tr></tbody></table></div><p>
	</p><p>
		If you need to serialize an Object to a byte array or deserialize a byte array back into an Object,
		Spring Integration provides symmetrical serialization transformers.
			</p><pre class="programlisting"> &lt;<span class="hl-tag">payload-serializing-transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"objectsIn"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"bytesOut"</span>/&gt;

 &lt;<span class="hl-tag">payload-deserializing-transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"bytesIn"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"objectsOut"</span>/&gt;</pre><p>
	</p><p>
		If you only need to add headers to a Message, and they are not dynamically determined by Message content,
		then referencing a custom implementation may be overkill. For that reason, Spring Integration provides the
		'header-enricher' element. 	</p><pre class="programlisting"> &lt;<span class="hl-tag">header-enricher</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"in"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"out"</span>&gt;
     &lt;<span class="hl-tag">header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"123"</span>/&gt;
     &lt;<span class="hl-tag">header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someBean"</span>/&gt;
 &lt;<span class="hl-tag">/header-enricher</span>&gt;</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformer-annotation"></a>9.3&nbsp;The @Transformer Annotation</h2></div></div></div><p>
      The <code class="interfacename">@Transformer</code> annotation can also be added to methods that expect either the
      <code class="interfacename">Message</code> type or the message payload type. The return value will be handled in the
      exact same way as described above in the section describing the &lt;transformer&gt; element.
      </p><pre class="programlisting">@Transformer
Order generateOrder(String productId) {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Order(productId);
}</pre><p>
    </p><p>
      Transformer methods may also accept the @Header and @Headers annotations that is documented in <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#annotations" title="B.5Â Annotation Support">Section&nbsp;B.5, âAnnotation Supportâ</a>
	      </p><pre class="programlisting">@Transformer
Order generateOrder(String productId, @Header(<span class="hl-string">"customerName"</span>) String customer) {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Order(productId, customer);
}</pre><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="splitter"></a>10.&nbsp;Splitter</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="splitter-annotation"></a>10.1&nbsp;Introduction</h2></div></div></div><p>The Splitter is a component whose role is to partition a message in
    several parts, and send the resulting messages to be processed
    independently. Very often, they are upstream producers in a pipeline that
    includes an Aggregator.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1890"></a>10.2&nbsp;Programming model</h2></div></div></div><p>The API for performing splitting consists from one base class,
    AbstractMessageSplitter, which is a MessageHandler implementation,
    encapsulating features which are common to splitters, such as filling in
    the appropriate message headers CORRELATION_ID, SEQUENCE_SIZE, and
    SEQUENCE_NUMBER on the messages that are produced. This allows to track
    down the messages and the results of their processing (in a typical
    scenario, these headers would be copied over to the messages that are
    produced by the various transforming endpoints), and use them, for
    example, in a Composed Message Processor scenario.</p><p>An excerpt from AbstractMessageSplitter can be seen below:</p><pre class="programlisting">public abstract class AbstractMessageSplitter
                extends AbstractReplyProducingMessageConsumer {
  ...
  protected abstract Object splitMessage(Message&lt;?&gt; message);

}</pre><p>For implementing a specific Splitter in an application, a developer
    can extend AbstractMessageSplitter and implement the splitMessage method,
    thus defining the actual logic for splitting the messages. The return
    value can be one of the following:</p><div class="itemizedlist"><ul type="disc"><li><p>a Collection (or subclass thereof) or an array of Message
        objects - in this case the messages will be sent as such (after the
        CORRELATION_ID, SEQUENCE_SIZE and SEQUENCE_NUMBER are populated).
        Using this approach gives more control to the developer, for example
        for populating custom message headers as part of the splitting
        process.</p></li><li><p>a Collection (or subclass thereof) or an array of non-Message
        objects - works like the prior case, except that each collection
        element will be used as a Message payload. Using this approach allows
        developers to focus on the domain objects without having to consider
        the Messaging system and produces code that is easier to test.</p></li><li><p>a Message or non-Message object (but not a Collection or an
        Array) - it works like the previous cases, except that there is a
        single message to be sent out.</p></li></ul></div><p>In Spring Integration, any POJO can implement the splitting
    algorithm, provided that it defines a method that accepts a single
    argument and has a return value. In this case, the return value of the
    method will be interpreted as described above. The input argument might
    either be a Message or a simple POJO. In the latter case, the splitter
    will receive the payload of the incoming message. Since this decouples
    the code from the Spring Integration API and will typically be easier
    to test, it is the recommended approach.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1913"></a>10.3&nbsp;Configuring a Splitter using XML</h2></div></div></div><p>A splitter can be configured through XML as follows:</p><pre class="programlisting">&lt;channel id="inputChannel"/&gt;

&lt;splitter id="splitter" <a name="split1"></a><img src="./Spring Integration Reference Manual_files/1.gif" alt="1" border="0">
  ref="splitterBean" <a name="split2"></a><img src="./Spring Integration Reference Manual_files/2.gif" alt="2" border="0">
  method="split" <a name="split3"></a><img src="./Spring Integration Reference Manual_files/3.gif" alt="3" border="0">
  input-channel="inputChannel" <a name="split4"></a><img src="./Spring Integration Reference Manual_files/4.gif" alt="4" border="0">
  output-channel="outputChannel" <a name="split5"></a><img src="./Spring Integration Reference Manual_files/5.gif" alt="5" border="0">/&gt;

&lt;channel id="outputChannel"/&gt;

&lt;beans:bean id="splitterBean" class="sample.PojoSplitter"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#split1"><img src="./Spring Integration Reference Manual_files/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The id of the splitter is
          <span class="emphasis"><em>optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#split2"><img src="./Spring Integration Reference Manual_files/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>A reference to a bean defined in the application context. The
          bean must implement the splitting logic as described in the section
          above. <span class="emphasis"><em>Optional</em></span>.
          If reference to a bean is not provided, then it is assumed that the <span class="emphasis"><em>payload</em></span> of the Message that arrived on the <code class="code">input-channel</code> is 
          an implementation of <span class="emphasis"><em>java.util.Collection</em></span> and the default splitting logic will be applied on such Collection, 
          incorporating each individual element into a Message and depositing it on the <code class="code">output-channel</code>.
          </p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#split3"><img src="./Spring Integration Reference Manual_files/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The method (defined on the bean specified above) that
          implements the splitting logic.
          <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#split4"><img src="./Spring Integration Reference Manual_files/4.gif" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The input channel of the splitter.
          <span class="emphasis"><em>Required</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#split5"><img src="./Spring Integration Reference Manual_files/5.gif" alt="5" border="0"></a> </p></td><td valign="top" align="left"><p>The channel where the splitter will send the results of
          splitting the incoming message. <span class="emphasis"><em>Optional (because incoming
          messages can specify a reply channel themselves)</em></span>.</p></td></tr></tbody></table></div><p>
        Using a "ref" attribute is generally recommended if the custom splitter handler implementation can be reused in other      
        <code class="code">&lt;splitter&gt;</code> definitions. However if the custom splitter handler implementation should be scoped to a
        single definition of the <code class="code">&lt;splitter&gt;</code>, you can configure an inner bean definition:
</p><pre class="programlisting">&lt;<span class="hl-tag">splitter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"testSplitter"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inChannel"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"split"</span>
								<span class="hl-attribute">output-channel</span>=<span class="hl-value">"outChannel"</span>&gt;
	&lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.TestSplitter"</span>/&gt;
&lt;<span class="hl-tag">/spliter</span>&gt;</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
       Using both a "ref" attribute and an inner handler definition in the same <code class="code">&lt;splitter&gt;</code>
       configuration is not allowed, as it creates an ambiguous condition and will result in an Exception being thrown.
    </p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1990"></a>10.4&nbsp;Configuring a Splitter with Annotations</h2></div></div></div><p>The <code class="interfacename">@Splitter</code> annotation is
    applicable to methods that expect either the
    <code class="interfacename">Message</code> type or the message payload type,
    and the return values of the method should be a collection of any type. If
    the returned values are not actual <code class="interfacename">Message</code>
    objects, then each of them will be sent as the payload of a message. Those
    messages will be sent to the output channel as designated for the endpoint
    on which the <code class="interfacename">@Splitter</code> is defined.
    </p><pre class="programlisting">@Splitter
List&lt;LineItem&gt; extractItems(Order order) {
    <span class="hl-keyword">return</span> order.getItems()
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="aggregator"></a>11.&nbsp;Aggregator</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aggregator-introduction"></a>11.1&nbsp;Introduction</h2></div></div></div><p>Basically a mirror-image of the Splitter, the Aggregator is a type
    of Message Handler that receives multiple Messages and combines them into
    a single Message. In fact, Aggregators are often downstream consumers in a
    pipeline that includes a Splitter.</p><p>Technically, the Aggregator is more complex than a Splitter, because
    it is required to maintain state (the Messages to-be-aggregated), to
    decide when the complete group of Messages is available, and to timeout if
    necessary. Furthermore, in case of a timeout, the Aggregator needs to know
    whether to send the partial results or to discard them to a separate
    channel.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aggregator-functionality"></a>11.2&nbsp;Functionality</h2></div></div></div><p>The Aggregator combines a group of related messages, by correlating
    and storing them, until the group is deemed complete. At that point, the
    Aggregator will create a single message by processing the whole group, and
    will send that aggregated message as output.</p><p>As messages might arrive with a certain delay (or certain messages
    from the group might not arrive at all), the Aggregator can specify a
    timeout (counted from the moment when the first message in the group has
    arrived), and whether, in the case of a timeout, the group should be
    discarded, or the Aggregator should merely attempt to create a single
    message out of what has arrived so far. An important aspect of
    implementing an Aggregator is providing the logic that has to be executed
    when the aggregation (creation of a single message out of many) takes
    place.</p><p>In Spring Integration, the grouping of the messages for aggregation
    is done by default based on their CORRELATION_ID message header (i.e. the
    messages with the same CORRELATION_ID will be grouped together). However,
    this can be customized, and the users can opt for other ways of
    specifying how the messages should be grouped together, by using a
    CorrelationStrategy (see below).</p><p>An important concern with respect to the timeout is, what happens if
    late messages arrive after the aggregation has taken place? In this case,
    a configuration option allows the user to decide whether they should be
    discarded or not.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aggregator-api"></a>11.3&nbsp;Programming model</h2></div></div></div><p>The Aggregation API consists of a number of classes:</p><div class="itemizedlist"><ul type="disc"><li><p>The base class <code class="code">AbstractMessageAggregator </code>and its
        subclass <code class="code">MethodInvokingMessageAggregator</code></p></li><li><p>The <code class="code">CompletionStrategy</code> interface and its default
        implementation <code class="code">SequenceSizeCompletionStrategy</code></p></li><li><p>The <code class="code">CorrelationStrategy</code> interface and its default
        implementation <code class="code">HeaderAttributeCorrelationStrategy</code></p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2060"></a>AbstractMessageAggregator</h3></div></div></div><p>The <code class="code">AbstractMessageAggregator</code> is a
      <code class="code">MessageHandler</code> implementation, encapsulating the common
      functionalities of an Aggregator, which are:
      </p><div class="itemizedlist"><ul type="disc"><li><p>correlating messages into a group to be aggregated</p></li><li><p>maintaining those messages until the group is complete</p></li><li><p>deciding when the group is in fact complete</p></li><li><p>processing the completed group into a single aggregated message</p></li><li><p>recognizing and responding to a timed-out completion attempt</p></li></ul></div><p>
      The responsibility of deciding how the messages should be grouped together
      is delegated to a <code class="code">CorrelationStrategy</code> instance. The responsibility
      of deciding whether the message group is complete is delegated to a
      <code class="code">CompletionStrategy</code> instance.</p><p>Here is a brief highlight of the base
      <code class="code">AbstractMessageAggregator</code> (the responsibility of
      implementing the aggregateMessages method is left to the
      developer):</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> AbstractMessageAggregator 
              <span class="hl-keyword">extends</span> AbstractMessageBarrierHandler {

  <span class="hl-keyword">private</span> <span class="hl-keyword">volatile</span> CompletionStrategy completionStrategy
                            = <span class="hl-keyword">new</span> SequenceSizeCompletionStrategy();
  ....

  <span class="hl-keyword">protected</span> <span class="hl-keyword">abstract</span> Message&lt;?&gt; aggregateMessages(List&lt;Message&lt;?&gt;&gt; messages);

}</pre>
      It also inherits the following default CorrelationStrategy:
      <pre class="programlisting"><span class="hl-keyword">private</span> <span class="hl-keyword">volatile</span> CorrelationStrategy correlationStrategy =
          <span class="hl-keyword">new</span> HeaderAttributeCorrelationStrategy(MessageHeaders.CORRELATION_ID);</pre><p>When appropriate, the simplest option is the <code class="code">DefaultMessageAggregator</code>.
      It creates a single Message whose payload is a List of the payloads received
      for a given group. It uses the default <code class="code">CorrelationStrategy</code> and
      <code class="code">CompletionStrategy</code> as shown above. This works well for simple
      Scatter Gather implementations with either a Splitter, Publish Subscribe Channel,
      or Recipient List Router upstream.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When using a Publish Subscribe Channel or Recipient List Router in this
        type of scenario, be sure to enable the flag to <span class="emphasis"><em>apply sequence</em></span>.
        That will add the necessary headers (correlation id, sequence number and sequence
        size). That behavior is enabled by default for Splitters in Spring Integration,
        but it is not enabled for the Publish Subscribe Channel or Recipient List
        Router because those components may be used in a variety of contexts where
        those headers are not necessary.</p></td></tr></tbody></table></div><p>When implementing a specific aggregator object for an application,
      a developer can extend <code class="code">AbstractMessageAggregator </code>and
      implement the <code class="code">aggregateMessages</code> method. However, there are
      better suited (which reads, less coupled to the API) solutions for
      implementing the aggregation logic, which can be configured easily
      either through XML or through annotations.</p><p>In general, any ordinary Java class (i.e. POJO) can implement the
      aggregation algorithm. For doing so, it must provide a method that
      accepts as an argument a single java.util.List (parametrized lists are
      supported as well). This method will be invoked for aggregating
      messages, as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>if the argument is a parametrized java.util.List, and the
          parameter type is assignable to Message, then the whole list of
          messages accumulated for aggregation will be sent to the
          aggregator</p></li><li><p>if the argument is a non-parametrized java.util.List or the
          parameter type is not assignable to Message, then the method will
          receive the payloads of the accumulated messages</p></li><li><p>if the return type is not assignable to Message, then it will
          be treated as the payload for a Message that will be created
          automatically by the framework.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In the interest of code simplicity, and promoting best practices
        such as low coupling, testability, etc., the preferred way of
        implementing the aggregation logic is through a POJO, and using the
        XML or annotation support for setting it up in the application.</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2144"></a>CompletionStrategy</h3></div></div></div><p>The <code class="code">CompletionStrategy</code> interface is defined as
      follows:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> CompletionStrategy {

  <span class="hl-keyword">boolean</span> isComplete(List&lt;Message&lt;?&gt;&gt; messages);

}</pre><p>In general, any ordinary Java class (i.e. POJO) can implement the
      completion decision mechanism. For doing so, it must provide a method
      that accepts as an argument a single java.util.List (parametrized lists
      are supported as well), and returns a boolean value. This method will be
      invoked after the arrival of a new message, to decide whether the group
      is complete or not, as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>if the argument is a parametrized java.util.List, and the
          parameter type is assignable to Message, then the whole list of
          messages accumulated in the group will be sent to the method</p></li><li><p>if the argument is a non-parametrized java.util.List or the
          parameter type is not assignable to Message, then the method will
          receive the payloads of the accumulated messages</p></li><li><p>the method must return true if the message group is complete
          and ready for aggregation, and false otherwise.</p></li></ul></div><p>Spring Integration provides an out-of-the box implementation for
      <code class="code">CompletionStrategy</code>, the
      <code class="code">SequenceSizeCompletionStrategy</code>. This implementation uses
      the SEQUENCE_NUMBER and SEQUENCE_SIZE of the arriving messages for
      deciding when a message group is complete and ready to be
      aggregated. As shown above, it is also the default strategy.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2174"></a>CorrelationStrategy</h3></div></div></div><p>The <code class="code">CorrelationStrategy</code> interface is defined as
      follows:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> CorrelationStrategy {

  Object getCorrelationKey(Message&lt;?&gt; message);

}</pre><p>The method shall return an Object which represents the correlation
      key used for grouping messages together. The key must satisfy the
      criteria used for a key in a Map with respect to the implementation of
      equals() and hashCode().</p><p>In general, any ordinary Java class (i.e. POJO) can implement the
      correlation decision mechanism, and the rules for mapping a message to
      a method's argument (or arguments) are the same as for a
      <code class="code">ServiceActivator</code> (including support for @Header
      annotations). The method must return a value, and the value must not be
      <code class="code">null</code>.</p><p>Spring Integration provides an out-of-the box implementation for
      <code class="code">CorrelationStrategy</code>, the
      <code class="code">HeaderAttributeCorrelationStrategy</code>. This implementation
      returns the value of one of the message headers (whose name is specified
      by a constructor argument) as the correlation key. By default, the
      correlation strategy is a HeaderAttributeCorrelationStrategy returning
      the value of the CORRELATION_ID header attribute.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aggregator-xml"></a>11.4&nbsp;Configuring an Aggregator with XML</h2></div></div></div><p>Spring Integration supports the configuration of an aggregator via
	XML through the &lt;aggregator/&gt; element. Below you can see an example of 
	an aggregator with all optional parameters defined.</p><pre class="programlisting">&lt;channel id="inputChannel"/&gt;

&lt;aggregator id="completelyDefinedAggregator" <a name="aggxml1"></a><img src="./Spring Integration Reference Manual_files/1.gif" alt="1" border="0">
    input-channel="inputChannel" <a name="aggxml2"></a><img src="./Spring Integration Reference Manual_files/2.gif" alt="2" border="0">
    output-channel="outputChannel"  <a name="aggxml3"></a><img src="./Spring Integration Reference Manual_files/3.gif" alt="3" border="0">
    discard-channel="discardChannel"  <a name="aggxml4"></a><img src="./Spring Integration Reference Manual_files/4.gif" alt="4" border="0">
    ref="aggregatorBean" <a name="aggxml5"></a><img src="./Spring Integration Reference Manual_files/5.gif" alt="5" border="0">
    method="add" <a name="aggxml6"></a><img src="./Spring Integration Reference Manual_files/6.gif" alt="6" border="0">
    completion-strategy="completionStrategyBean"  <a name="aggxml7"></a><img src="./Spring Integration Reference Manual_files/7.gif" alt="7" border="0">
    completion-strategy-method="checkCompleteness" <a name="aggxml8"></a><img src="./Spring Integration Reference Manual_files/8.gif" alt="8" border="0">
    correlation-strategy="correlationStrategyBean" <a name="aggxmlCorrelationStrategy"></a><img src="./Spring Integration Reference Manual_files/9.gif" alt="9" border="0">
    correlation-strategy-method="groupNumbersByLastDigit" <a name="aggxmlCorrelationStrategyMethod"></a><img src="./Spring Integration Reference Manual_files/10.gif" alt="10" border="0">
    timeout="42" <a name="aggxml9"></a><img src="./Spring Integration Reference Manual_files/11.gif" alt="11" border="0">
    send-partial-result-on-timeout="true" <a name="aggxml10"></a><img src="./Spring Integration Reference Manual_files/12.gif" alt="12" border="0">
    reaper-interval="135" <a name="aggxml11"></a><img src="./Spring Integration Reference Manual_files/13.gif" alt="13" border="0">
    tracked-correlation-id-capacity="99" <a name="aggxml12"></a><img src="./Spring Integration Reference Manual_files/14.gif" alt="14" border="0">
    send-timeout="86420000" <a name="aggxml13"></a><img src="./Spring Integration Reference Manual_files/15.gif" alt="15" border="0"> /&gt; 

&lt;channel id="outputChannel"/&gt;

&lt;bean id="aggregatorBean" class="sample.PojoAggregator"/&gt;

&lt;bean id="completionStrategyBean" class="sample.PojoCompletionStrategy"/&gt;

&lt;bean id="correlationStrategyBean" class="sample.PojoCorrelationStrategy"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml1"><img src="./Spring Integration Reference Manual_files/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The id of the aggregator is
        <span class="emphasis"><em>optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml2"><img src="./Spring Integration Reference Manual_files/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The input channel of the aggregator.
        <span class="emphasis"><em>Required</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml3"><img src="./Spring Integration Reference Manual_files/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The channel where the aggregator will send the aggregation
        results. <span class="emphasis"><em>Optional (because incoming messages can specify a
        reply channel themselves)</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml4"><img src="./Spring Integration Reference Manual_files/4.gif" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The channel where the aggregator will send the messages that
        timed out (if <code class="code">send-partial-results-on-timeout</code> is
        <span class="emphasis"><em>false</em></span>). <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml5"><img src="./Spring Integration Reference Manual_files/5.gif" alt="5" border="0"></a> </p></td><td valign="top" align="left"><p>A reference to a bean defined in the application context. The
        bean must implement the aggregation logic as described above.
        <span class="emphasis"><em>Required</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml6"><img src="./Spring Integration Reference Manual_files/6.gif" alt="6" border="0"></a> </p></td><td valign="top" align="left"><p>A method defined on the bean referenced by <code class="code">ref</code>,
        <span class="emphasis"><em>that implements the message aggregation
        algorithm.</em></span> <span class="emphasis"><em>Optional, with restrictions (see
        above).</em></span></p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml7"><img src="./Spring Integration Reference Manual_files/7.gif" alt="7" border="0"></a> </p></td><td valign="top" align="left"><p>A reference to a bean that implements the decision algorithm as
        to whether a given message group is complete. The bean can be an
        implementation of the CompletionStrategy interface or a POJO. In the
        latter case the completion-strategy-method attribute must be defined
        as well. <span class="emphasis"><em>Optional (by default, the aggregator will use
        sequence size) </em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml8"><img src="./Spring Integration Reference Manual_files/8.gif" alt="8" border="0"></a> </p></td><td valign="top" align="left"><p>A method defined on the bean referenced by
        <code class="code">completion-strategy</code>, <span class="emphasis"><em>that implements the
        completion decision algorithm.</em></span> <span class="emphasis"><em>Optional, with
        restrictions (requires <code class="code">completion-strategy</code> to be
        present).</em></span></p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxmlCorrelationStrategy"><img src="./Spring Integration Reference Manual_files/9.gif" alt="9" border="0"></a> </p></td><td valign="top" align="left"><p>A reference to a bean that implements the correlation strategy.
        The bean can be an implementation of the CorrelationStrategy interface
        or a POJO. In the latter case the correlation-strategy-method
        attribute must be defined as well. <span class="emphasis"><em>Optional (by default, the
        aggregator will use the correlation id header attribute)
        </em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxmlCorrelationStrategyMethod"><img src="./Spring Integration Reference Manual_files/10.gif" alt="10" border="0"></a> </p></td><td valign="top" align="left"><p>A method defined on the bean referenced by
        <code class="code">correlation-strategy</code>, <span class="emphasis"><em>that implements the
        correlation key algorithm.</em></span> <span class="emphasis"><em>Optional, with
        restrictions (requires <code class="code">correlation-strategy</code> to be
        present).</em></span></p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml9"><img src="./Spring Integration Reference Manual_files/11.gif" alt="11" border="0"></a> </p></td><td valign="top" align="left"><p>The timeout (in milliseconds) for aggregating messages (counted
        from the arrival of the first message). <span class="emphasis"><em>Optional</em></span>.
        </p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml10"><img src="./Spring Integration Reference Manual_files/12.gif" alt="12" border="0"></a> </p></td><td valign="top" align="left"><p>Whether upon the expiration of the timeout, the aggregator shall
        try to aggregate the messages that have already arrived. <span class="emphasis"><em>Optional
        (false by default)</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml11"><img src="./Spring Integration Reference Manual_files/13.gif" alt="13" border="0"></a> </p></td><td valign="top" align="left"><p>The interval (in milliseconds) at which a reaper task is
        executed, checking if there are any timed out groups.
        <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml12"><img src="./Spring Integration Reference Manual_files/14.gif" alt="14" border="0"></a> </p></td><td valign="top" align="left"><p>The capacity of the correlation id tracker. Remembers the
        already processed correlation ids, preventing the formation of new
        groups for messages that arrive after their group has been already
        processed (aggregated or discarded). Set this value to 0 if you
        do not want the messages to be discarded in such a scenario.
        <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggxml13"><img src="./Spring Integration Reference Manual_files/15.gif" alt="15" border="0"></a> </p></td><td valign="top" align="left"><p>The timeout for sending the aggregated messages to the
        output or reply channel. <span class="emphasis"><em>Optional</em></span>.</p></td></tr></tbody></table></div><p>Using a "ref" attribute is generally recommended if a custom aggregator handler
    implementation can be reused in other <code class="code">&lt;aggregator&gt;</code> definitions.
    However if a custom aggregator handler implementation should be scoped to a concrete
    definition of the <code class="code">&lt;aggregator&gt;</code>, you can use an inner bean definition
    (starting with version 1.0.3) for custom aggregator handlers within the
    <code class="code">&lt;aggregator&gt;</code> element:
</p><pre class="programlisting">&lt;<span class="hl-tag">aggregator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"sum"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>&gt;
    &lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.foo.ExampleAggregator"</span>/&gt;
&lt;<span class="hl-tag">/aggregator</span>&gt;</pre><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Using both a "ref" attribute and an inner bean definition in the same
      <code class="code">&lt;aggregator&gt;</code> configuration is not allowed, as it creates an
      ambiguous condition. In such cases, an Exception will be thrown.
      </p></td></tr></tbody></table></div><p>An example implementation of the aggregator bean looks as follows:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PojoAggregator {

  <span class="hl-keyword">public</span> Long add(List&lt;Long&gt; results) {
    <span class="hl-keyword">long</span> total = 0l;
    <span class="hl-keyword">for</span> (<span class="hl-keyword">long</span> partialResult: results) {
      total += partialResult;
    }
    <span class="hl-keyword">return</span> total;
  }

}</pre><p>An implementation of the completion strategy bean for the example
    above may be as follows:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PojoCompletionStrategy {
...
  <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> checkCompleteness(List&lt;Long&gt; numbers) {
    <span class="hl-keyword">int</span> sum = 0;
    <span class="hl-keyword">for</span> (<span class="hl-keyword">long</span> number: numbers) {
      sum += number;
    }
    <span class="hl-keyword">return</span> sum &gt;= maxValue;
  }
}</pre><p>

      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Wherever it makes sense, the completion strategy method and
        the aggregator method can be combined in a single bean.</p></td></tr></tbody></table></div><p>
    </p><p>An implementation of the correlation strategy bean for the example
    above may be as follows:</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PojoCorrelationStrategy {
...
  <span class="hl-keyword">public</span> Long groupNumbersByLastDigit(Long number) {
    <span class="hl-keyword">return</span> number % 10;
  }
}</pre><p>For example, this aggregator would group numbers by some criterion
    (in our case the remainder after dividing by 10) and will hold the group
    until the sum of the numbers which represents the payload exceeds a
    certain value.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Wherever it makes sense, the completion strategy method, correlation
      strategy method and the aggregator method can be combined in a single bean
      (all of them or any two).</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aggregator-annotations"></a>11.5&nbsp;Configuring an Aggregator with Annotations</h2></div></div></div><p>An aggregator configured using annotations can look like
    this.</p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Waiter {
  ... 

  @Aggregator  
  <span class="hl-keyword">public</span> Delivery aggregatingMethod(List&lt;OrderItem&gt; items) {
    ...
  }

  @CompletionStrategy 
  <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> completionChecker(List&lt;Message&lt;?&gt;&gt; messages) {
    ...
  }

  @CorrelationStrategy 
  <span class="hl-keyword">public</span> String correlateBy(OrderItem item) {
    ...
  }

}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#aggann"><img src="./Spring Integration Reference Manual_files/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>An annotation indicating that this method shall be used as an
        aggregator. Must be specified if this class will be used as an
        aggregator.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#agganncs"><img src="./Spring Integration Reference Manual_files/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p><a name="aggann2"></a>An annotation indicating that this method shall be
        used as the completion strategy of an aggregator. If not present on
        any method, the aggregator will use the
        SequenceSizeCompletionStrategy.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#agganncorrs"><img src="./Spring Integration Reference Manual_files/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p><a name="agann3"></a>An annotation indicating that this method shall be
        used as the correlation strategy of an aggregator. If no correlation
        strategy is indicated, the aggregator will use the
        HeaderAttributeCorrelationStrategy based on CORRELATION_ID.</p></td></tr></tbody></table></div><p>All of the configuration options provided by the xml element are also
    available for the @Aggregator annotation.</p><p>The aggregator can be either referenced explicitly from XML or, if
    the @MessageEndpoint is defined on the class, detected automatically
    through classpath scanning.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="resequencer"></a>12.&nbsp;Resequencer</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2431"></a>12.1&nbsp;Introduction</h2></div></div></div><p>Related to the Aggregator, albeit different from a functional
    standpoint, is the Resequencer. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resequencer-functionality"></a>12.2&nbsp;Functionality</h2></div></div></div><p>The Resequencer works in a similar way to the Aggregator, in the
    sense that it uses the CORRELATION_ID to store messages in groups, the
    difference being that the Resequencer does not process the messages in
    any way. It simply releases them in the order of their SEQUENCE_NUMBER
    header values.</p><p>With respect to that, the user might opt to release all messages at
    once (after the whole sequence, according to the SEQUENCE_SIZE, has been
    released), or as soon as a valid sequence is available. Another option is
    to set a timeout, deciding whether to drop the whole sequence if the
    timeout has expired, and not all messages have arrived, or to release the
    messages accumulated so far, in the appropriate order.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2443"></a>12.3&nbsp;Configuring a Resequencer with XML</h2></div></div></div><p>Configuring a resequencer requires only including the appropriate
    element in XML.</p><p>A sample resequencer configuration is shown below.</p><pre class="programlisting">&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inputChannel"</span>/&gt;

&lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outputChannel"</span>/&gt;

&lt;<span class="hl-tag">resequencer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"completelyDefinedResequencer"</span> 
  <span class="hl-attribute">input-channel</span>=<span class="hl-value">"inputChannel"</span> 
  <span class="hl-attribute">output-channel</span>=<span class="hl-value">"outputChannel"</span> 
  <span class="hl-attribute">discard-channel</span>=<span class="hl-value">"discardChannel"</span> 
  <span class="hl-attribute">release-partial-sequences</span>=<span class="hl-value">"true"</span> 
  <span class="hl-attribute">timeout</span>=<span class="hl-value">"42"</span> 
  <span class="hl-attribute">send-partial-result-on-timeout</span>=<span class="hl-value">"true"</span> 
  <span class="hl-attribute">reaper-interval</span>=<span class="hl-value">"135"</span> 
  <span class="hl-attribute">tracked-correlation-id-capacity</span>=<span class="hl-value">"99"</span> 
  <span class="hl-attribute">send-timeout</span>=<span class="hl-value">"86420000"</span>  /&gt; </pre><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a name="resxml1"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml1-co"><img src="./Spring Integration Reference Manual_files/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The id of the resequencer is
          <span class="emphasis"><em>optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml2"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml2-co"><img src="./Spring Integration Reference Manual_files/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The input channel of the resequencer.
          <span class="emphasis"><em>Required</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml3"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml3-co"><img src="./Spring Integration Reference Manual_files/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The channel where the resequencer will send the reordered
          messages. <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml4"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml4-co"><img src="./Spring Integration Reference Manual_files/4.gif" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The channel where the resequencer will send the messages that
          timed out (if <code class="code">send-partial-result-on-timeout</code> is
          <span class="emphasis"><em>false)</em></span>. <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml5"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml5-co"><img src="./Spring Integration Reference Manual_files/5.gif" alt="5" border="0"></a> </p></td><td valign="top" align="left"><p>Whether to send out ordered sequences as soon as they are
          available, or only after the whole message group arrives.
          <span class="emphasis"><em>Optional (true by default)</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml6"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml6-co"><img src="./Spring Integration Reference Manual_files/6.gif" alt="6" border="0"></a> </p></td><td valign="top" align="left"><p>The timeout (in milliseconds) for reordering message sequences (counted from the
          arrival of the first message). <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml7"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml7-co"><img src="./Spring Integration Reference Manual_files/7.gif" alt="7" border="0"></a> </p></td><td valign="top" align="left"><p>Whether, upon the expiration of the timeout, the ordered group
          shall be sent out (even if some of the messages are missing).
          <span class="emphasis"><em>Optional (false by default)</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml8"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml8-co"><img src="./Spring Integration Reference Manual_files/8.gif" alt="8" border="0"></a> </p></td><td valign="top" align="left"><p>The interval (in milliseconds) at which a reaper task is
          executed, checking if there are any timed out groups.
          <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml9"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml9-co"><img src="./Spring Integration Reference Manual_files/9.gif" alt="9" border="0"></a> </p></td><td valign="top" align="left"><p>The capacity of the correlation id tracker. Remembers the
          already processed correlation ids, preventing the formation of new
          groups for messages that arrive after their group has been already
          processed (reordered or discarded).
          <span class="emphasis"><em>Optional</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a name="resxml10"></a><a href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#resxml10-co"><img src="./Spring Integration Reference Manual_files/10.gif" alt="10" border="0"></a> </p></td><td valign="top" align="left"><p>The timeout for sending out messages.
          <span class="emphasis"><em>Optional</em></span>.</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
       Since there is no custom behavior to be implemented in Java classes for resequencers, there is no annotation support for it. 
    </td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="delayer"></a>13.&nbsp;Delayer</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="delayer-introduction"></a>13.1&nbsp;Introduction</h2></div></div></div><p>
      A Delayer is a simple endpoint that allows a Message flow to be delayed by a certain interval. When
      a Message is delayed, the original sender will not block. Instead, the delayed Messages will be
      scheduled with an instance of <code class="interfacename">java.util.concurrent.ScheduledExecutorService</code>
      to be sent to the output channel after the delay has passed. This approach is scalable even for
      rather long delays, since it does not result in a large number of blocked sender Threads. On the
      contrary, in the typical case a thread pool will be used for the actual execution of releasing the
      Messages. Below you will find several examples of configuring a Delayer.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="delayer-namespace"></a>13.2&nbsp;The &lt;delayer&gt; Element</h2></div></div></div><p>
      The &lt;delayer&gt; element is used to delay the Message flow between two Message Channels.
      As with the other endpoints, you can provide the "input-channel" and "output-channel" attributes,
      but the delayer also requires at least the 'default-delay' attribute with the number of milliseconds
      that each Message should be delayed.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">delayer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">default-delay</span>=<span class="hl-value">"3000"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>/&gt;</pre><p>
      If you need per-Message determination of the delay, then you can also provide the name of a header
      within the 'delay-header-name' attribute:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">delayer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
          <span class="hl-attribute">default-delay</span>=<span class="hl-value">"3000"</span> <span class="hl-attribute">delay-header-name</span>=<span class="hl-value">"delay"</span>/&gt;</pre><p>
      In the example above the 3 second delay would only apply in the case that the header value is
      not present for a given inbound Message. If you only want to apply a delay to Messages that have
      an explicit header value, then you can set the 'default-delay' to 0. For any Message that has a
      delay of 0 (or less), the Message will be sent directly. In fact, if there is not a positive delay
      value for a Message, it will be sent to the output channel on the calling Thread.
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
        The delay handler actually supports header values that represent an interval in milliseconds (any
        Object whose <code class="methodname">toString()</code> method produces a value that can be parsed into a
        Long) as well as <code class="classname">java.util.Date</code> instances representing an absolute time.
        In the former case, the milliseconds will be counted from the current time (e.g. a value of 5000
        would delay the Message for at least 5 seconds from the time it is received by the Delayer). In
        the latter case, with an actual Date instance, the Message will not be released until that Date
        occurs. In either case, a value that equates to a non-positive delay, or a Date in the past, will
        not result in any delay. Instead, it will be sent directly to the output channel in the original
        sender's Thread.
      </td></tr></tbody></table></div><p>
    </p><p>
      The default scheduler will have a thread pool of size 1. If you want to configure and provide a
      different scheduler, you can provide the reference through the 'scheduler' attribute:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">delayer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
          <span class="hl-attribute">default-delay</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">delay-header-name</span>=<span class="hl-value">"delay"</span>
          <span class="hl-attribute">scheduler</span>=<span class="hl-value">"someScheduledExecutorService"</span>/&gt;</pre><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chain"></a>14.&nbsp;Message Handler Chain</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chain-introduction"></a>14.1&nbsp;Introduction</h2></div></div></div><p>
      The <code class="classname">MessageHandlerChain</code> is an implementation of
      <code class="interfacename">MessageHandler</code> that can be configured as a single Message Endpoint while
      actually delegating to a chain of other handlers, such as Filters, Transformers, Splitters, and so on.
      This can lead to a much simpler configuration when several handlers need to be connected in a fixed, linear
      progression. For example, it is fairly common to provide a Transformer before other components. Similarly, when
      providing a <span class="emphasis"><em>Filter</em></span> before some other component in a chain, you are essentially creating a
      <a class="ulink" href="http://www.eaipatterns.com/MessageSelector.html" target="_top">Selective Consumer</a>. In either case, the
      chain only requires a single input-channel and a single output-channel as opposed to the configuration of
      channels for each individual component.
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
        Spring Integration's <span class="emphasis"><em>Filter</em></span> provides a boolean property 'throwExceptionOnRejection'. When
        providing multiple Selective Consumers on the same point-to-point channel with different acceptance criteria,
        this value should be set to 'true' (the default is false) so that the dispatcher will know that the Message was
        rejected and as a result will attempt to pass the Message on to other subscribers. If the Exception were not
        thrown, then it would appear to the dispatcher as if the Message had been passed on successfully even though
        the Filter had <span class="emphasis"><em>dropped</em></span> the Message to prevent further processing.
      </td></tr></tbody></table></div><p>
    </p><p>
		The handler chain simplifies configuration while internally maintaining the same degree of loose coupling between
		components, and it is trivial to modify the configuration if at some point a non-linear arrangement is required.
    </p><p>
		Internally, the chain will be expanded into a linear setup of the listed endpoints, separated by direct channels.
		The reply channel header will not be taken into account within the chain: only after the last handler is invoked
		will the resulting message be forwarded on to the reply channel or the chain's output channel. Because of this
		setup all handlers except the last require a <code class="methodname">setOutputChannel</code> implementation. The last
		handler only needs an output channel if the outputChannel on the MessageHandlerChain is set.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
				As with other endpoints, the output-channel is optional. If there is a reply Message at the end of the
				chain, the output-channel takes precedence, but if not available, the chain handler will check for a
				reply channel header on the inbound Message.
			</p></td></tr></tbody></table></div><p>
    </p><p>
		In most cases there is no need to implement MessageHandlers yourself. The next section will focus on namespace 
		support for the chain element. Most Spring Integration endpoints, like Service Activators and Transformers, are 
		suitable for use within a <code class="classname">MessageHandlerChain</code>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chain-namespace"></a>14.2&nbsp;The &lt;chain&gt; Element</h2></div></div></div><p>
      The &lt;chain&gt; element provides an 'input-channel' attribute, and if the last element in the chain is capable
      of producing reply messages (optional), it also supports an 'output-channel' attribute. The sub-elements are then
      filters, transformers, splitters, and service-activators. The last element may also be a router.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">chain</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>&gt;
     &lt;<span class="hl-tag">filter</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someSelector"</span> <span class="hl-attribute">throw-exception-on-rejection</span>=<span class="hl-value">"true"</span>/&gt;
     &lt;<span class="hl-tag">header-enricher</span> <span class="hl-attribute">error-channel</span>=<span class="hl-value">"customErrorChannel"</span>&gt;
         &lt;<span class="hl-tag">header</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"bar"</span>/&gt;
     &lt;<span class="hl-tag">/header-enricher</span>&gt;
     &lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someService"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"someMethod"</span>/&gt;
 &lt;<span class="hl-tag">/chain</span>&gt;</pre><p>
    </p><p>
		The &lt;header-enricher&gt; element used in the above example will set a message header with name "foo" and
		value "bar" on the message. A header enricher is a specialization of Transformer that touches only header
		values. You could obtain the same result by implementing a MessageHandler that did the header modifications
		and wiring that as a bean.
	</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="bridge"></a>15.&nbsp;Messaging Bridge</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bridge-introduction"></a>15.1&nbsp;Introduction</h2></div></div></div><p>
      A Messaging Bridge is a relatively trivial endpoint that simply connects two Message Channels or Channel
      Adapters. For example, you may want to connect a <code class="interfacename">PollableChannel</code> to a
      <code class="interfacename">SubscribableChannel</code> so that the subscribing endpoints do not have to worry
      about any polling configuration. Instead, the Messaging Bridge provides the polling configuration.
    </p><p>
      By providing an intermediary poller between two channels, a Messaging Bridge can be used to throttle inbound
      Messages. The poller's trigger will determine the rate at which messages arrive on the second channel, and the
      poller's "maxMessagesPerPoll" property will enforce a limit on the throughput.
    </p><p>
      Another valid use for a Messaging Bridge is to connect two different systems. In such a scenario, Spring 
      Integration's role would be limited to making the connection between these systems and managing a poller
      if necessary. It is probably more common to have at least a <span class="emphasis"><em>Transformer</em></span> between the
      two systems to translate between their formats, and in that case, the channels would be provided as the
      'input-channel' and 'output-channel' of a Transformer endpoint. If data format translation is not required,
      the Messaging Bridge may indeed be sufficient.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bridge-namespace"></a>15.2&nbsp;The &lt;bridge&gt; Element</h2></div></div></div><p>
      The &lt;bridge&gt; element is used to create a Messaging Bridge between two Message Channels or Channel Adapters.
      Simply provide the "input-channel" and "output-channel" attributes:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">bridge</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>/&gt;</pre><p>
      As mentioned above, a common use case for the Messaging Bridge is to connect a
      <code class="interfacename">PollableChannel</code> to a <code class="interfacename">SubscribableChannel</code>, and when
      performing this role, the Messaging Bridge may also serve as a throttler:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">bridge</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"pollable"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"subscribable"</span>&gt;
     &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"10"</span>&gt;
         &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"5"</span> <span class="hl-attribute">time-unit</span>=<span class="hl-value">"SECONDS"</span>/&gt;
     &lt;<span class="hl-tag">/poller</span>&gt;
 &lt;<span class="hl-tag">/bridge</span>&gt;</pre><p>
    </p><p>
      Connecting Channel Adapters is just as easy. Here is a simple echo example between the "stdin" and "stdout"
      adapters from Spring Integration's "stream" namespace.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">stream:stdin-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"stdin"</span>/&gt;

 &lt;<span class="hl-tag">stream:stdout-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"stdout"</span>/&gt;

 &lt;<span class="hl-tag">bridge</span> <span class="hl-attribute">id</span>=<span class="hl-value">"echo"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"stdin"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"stdout"</span>/&gt;</pre><p>
      Of course, the configuration would be similar for other (potentially more useful) Channel Adapter bridges, such
      as File to JMS, or Mail to File. The various Channel Adapters will be discussed in upcoming chapters.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If no 'output-channel' is defined on a bridge, the reply channel provided by the inbound Message will
      be used, if available. If neither output or reply channel is available, an Exception will be thrown.</p></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="gateway"></a>16.&nbsp;Inbound Messaging Gateways</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gateway-simple"></a>16.1&nbsp;SimpleMessagingGateway</h2></div></div></div><p>
      Even though the <code class="classname">MessageChannelTemplate</code> is fairly straightforward, it does not hide the
      details of messaging from your application code. To support working with plain Objects instead of messages,
      Spring Integration provides <code class="classname">SimpleMessagingGateway</code> with the following methods:
      </p><pre class="programlisting"> <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> send(Object object) { ... }

 <span class="hl-keyword">public</span> Object receive() { ... }

 <span class="hl-keyword">public</span> Object sendAndReceive(Object object) { ... }

 Message&lt;?&gt; sendAndReceiveMessage(Object object);</pre><p>
      It enables configuration of a request and/or reply channel and delegates to instances of the
      <code class="interfacename">InboundMessageMapper</code> and <code class="interfacename">OutboundMessageMapper</code>
      strategy interfaces.
      </p><pre class="programlisting"> SimpleMessagingGateway gateway = <span class="hl-keyword">new</span> SimpleMessagingGateway(inboundMapper, outboundMapper);
 gateway.setRequestChannel(requestChannel);
 gateway.setReplyChannel(replyChannel);
 Object result = gateway.sendAndReceive(<span class="hl-string">"test"</span>);</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gateway-proxy"></a>16.2&nbsp;GatewayProxyFactoryBean</h2></div></div></div><p>
      Working with Objects instead of Messages is an improvement. However, it would be even better to have no
      dependency on the Spring Integration API at all - including the gateway class. For that reason, Spring
      Integration also provides a <code class="classname">GatewayProxyFactoryBean</code> that generates a proxy for
      any interface and internally invokes the gateway methods shown above. Namespace support is also
      provided as demonstrated by the following example.
      </p><pre class="programlisting">&lt;<span class="hl-tag">gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"fooService"</span>
         <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.example.FooService"</span>
         <span class="hl-attribute">default-request-channel</span>=<span class="hl-value">"requestChannel"</span>
         <span class="hl-attribute">default-reply-channel</span>=<span class="hl-value">"replyChannel"</span>/&gt;</pre><p>
      Then, the "fooService" can be injected into other beans, and the code that invokes the methods on that
      proxied instance of the FooService interface has no awareness of the Spring Integration API. The general
      approach is similar to that of Spring Remoting (RMI, HttpInvoker, etc.). See the "Samples" Appendix for
      an example that uses this "gateway" element (in the Cafe demo).
	</p><p>
      The reason that the attributes on the 'gateway' element are named 'default-request-channel' and
      'default-reply-channel' is that you may also provide per-method channel references by using the
      @Gateway annotation.
      </p><pre class="programlisting"> <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Cafe {

     @Gateway(requestChannel=<span class="hl-string">"orders"</span>)
     <span class="hl-keyword">void</span> placeOrder(Order order);

 }</pre><p>
    </p><p>
      It is also possible to pass values to be interpreted as Message headers on the Message
      that is created and sent to the request channel by using the @Header annotation:
	  </p><pre class="programlisting"> <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FileWriter {

     @Gateway(requestChannel=<span class="hl-string">"filesOut"</span>)
     <span class="hl-keyword">void</span> write(<span class="hl-keyword">byte</span>[] content, @Header(FileHeaders.FILENAME) String filename);

 }</pre><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="files"></a>17.&nbsp;File Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="file-intro"></a>17.1&nbsp;Introduction</h2></div></div></div><p>
			Spring Integration's File support extends the Spring Integration Core with
			a dedicated vocabulary to deal with reading, writing, and transforming files.
			It provides a namespace that enables elements defining Channel Adapters dedicated
			to files and support for Transformers that can read file contents into strings or
			byte arrays.
    	</p><p>
			This section will explain the workings of <code class="classname">FileReadingMessageSource</code>
			and <code class="classname">FileWritingMessageHandler</code> and how to configure them as
			<span class="emphasis"><em>beans</em></span>. Also the support for dealing with files through file specific
			implementations of <code class="interfacename">Transformer</code> will be discussed. Finally the
			file specific namespace will be explained.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="file-reading"></a>17.2&nbsp;Reading Files</h2></div></div></div><p>
			A <code class="classname">FileReadingMessageSource</code> can be used to consume files from the filesystem.
			This is an implementation of <code class="interfacename">MessageSource</code> that creates messages from
			a file system directory. </p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pollableFileSource"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.FileReadingMessageSource"</span>
        <span class="hl-attribute">p:inputDirectory</span>=<span class="hl-value">"file:${input.directory}"</span>/&gt;</pre><p>
		</p><p>
			To prevent creating messages for certain files, you may supply a
			<code class="interfacename">FileListFilter</code>. By default, an
			<code class="classname">AcceptOnceFileListFilter</code> is used. This filter
			ensures files are picked up only once from the directory.
			</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pollableFileSource"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.FileReadingMessageSource"</span>
        <span class="hl-attribute">p:inputDirectory</span>=<span class="hl-value">"file:${input.directory}"</span>
        <span class="hl-attribute">p:filter-ref</span>=<span class="hl-value">"customFilterBean"</span>/&gt;</pre><p>
		</p><p>
			A common problem with reading files is that a file may be detected before
			it is ready. The default <code class="classname">AcceptOnceFileListFilter</code>
			does not prevent this. In most cases, this can be prevented if the
			file-writing process renames each file as soon as it is ready for
			reading. A pattern-matching filter that accepts only files that are
			ready (e.g. based on a known suffix), composed with the default
			<code class="classname">AcceptOnceFileListFilter</code> allows for this.
			The <code class="classname">CompositeFileListFilter</code> enables the
			composition.
			</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pollableFileSource"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.FileReadingMessageSource"</span>
        <span class="hl-attribute">p:inputDirectory</span>=<span class="hl-value">"file:${input.directory}"</span>
        <span class="hl-attribute">p:filter-ref</span>=<span class="hl-value">"compositeFilter"</span>/&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"compositeFilter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.CompositeFileListFilter"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">list</span>&gt;
            &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.AcceptOnceFileListFilter"</span> /&gt;
            &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.file.PatternMatchingFileListFilter"</span>&gt;
                &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"^test.*$"</span>/&gt;
            &lt;<span class="hl-tag">/bean</span>&gt;
        &lt;<span class="hl-tag">/list</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
		</p><p>
			The configuration can be simplified using the file specific namespace. To do
			this use the following template.
			</p><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
	<span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="hl-attribute">xmlns:integration</span>=<span class="hl-value">"http://www.springframework.org/schema/integration"</span>
	<span class="hl-attribute">xmlns:file</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/file"</span>
	<span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
			http://www.springframework.org/schema/integration
			http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
			http://www.springframework.org/schema/integration/file
			http://www.springframework.org/schema/integration/file/spring-integration-file-1.0.xsd"</span>&gt;
&lt;<span class="hl-tag">/beans</span>&gt;</pre><p>
			Within this namespace you can reduce the FileReadingMessageSource and wrap
			it in an inbound Channel Adapter like this:
			</p><pre class="programlisting"> &lt;<span class="hl-tag">file:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filesIn"</span>
       <span class="hl-attribute">directory</span>=<span class="hl-value">"file:${input.directory}"</span>/&gt;
 					
 &lt;<span class="hl-tag">file:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filesIn"</span>
        <span class="hl-attribute">directory</span>=<span class="hl-value">"file:${input.directory}"</span> 
        <span class="hl-attribute">filter</span>=<span class="hl-value">"customFilterBean"</span> /&gt;							

 &lt;<span class="hl-tag">file:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filesIn"</span>
        <span class="hl-attribute">directory</span>=<span class="hl-value">"file:${input.directory}"</span> 
        <span class="hl-attribute">filename-pattern</span>=<span class="hl-value">"^test.*$"</span> /&gt; 							</pre><p>
			The first channel adapter is relying on the default filter that just prevents
			duplication, the second is using a custom filter, and the third is using the
			<span class="emphasis"><em>filename-pattern</em></span> attribute to add a <code class="classname">Pattern</code>
			based filter to the <code class="classname">FileReadingMessageSource</code>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="file-writing"></a>17.3&nbsp;Writing files</h2></div></div></div><p>
			To write messages to the file system you can use a
			<code class="classname">FileWritingMessageHandler</code>. This class can deal with
			File, String, or byte array payloads. In its simplest form the
			<code class="classname">FileWritingMessageHandler </code> only requires a
			destination directory for writing the files. The name of the file to be
			written is determined by the handler's <code class="classname">FileNameGenerator</code>.
			The default implementation looks for a Message header whose key matches
			the constant defined as <code class="code">FileHeaders.FILENAME</code>.
		</p><p>
			Additionally, you can configure the encoding and the charset that
			will be used in case of a String payload.
		</p><p>
			To make things easier you can configure the FileWritingMessageHandler as
			part of an outbound channel adapter using the namespace.
			</p><pre class="programlisting"> &lt;<span class="hl-tag">file:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filesOut"</span> <span class="hl-attribute">directory</span>=<span class="hl-value">"file:${input.directory.property}"</span>/&gt;</pre><p>
		</p><p>
		The namespace based configuration also supports a <code class="code">delete-source-files</code> attribute.
		If set to <code class="code">true</code>, it will trigger deletion of the original source files after writing
		to a destination. The default value for that flag is <code class="code">false</code>.
		</p><pre class="programlisting"> &lt;<span class="hl-tag">file:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"filesOut"</span>
             <span class="hl-attribute">directory</span>=<span class="hl-value">"file:${output.directory}"</span> 
             <span class="hl-attribute">delete-source-files</span>=<span class="hl-value">"true"</span>/&gt;</pre><p>
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
				The <code class="code">delete-source-files</code> attribute will only have an effect if the inbound
				Message has a File payload or if the <code class="classname">FileHeaders.ORIGINAL_FILE</code> header
				value contains either the source File instance or a String representing the original file path.
			</p></td></tr></tbody></table></div><p>
		</p><p>
			In cases where you want to continue processing messages based on the written File you can use
			the <code class="code">outbound-gateway</code> instead. It plays a very similar role as the
			<code class="code">outbound-channel-adapter</code>. However after writing the File, it will also send it
			to the reply channel as the payload of a Message.
		</p><pre class="programlisting"> &lt;<span class="hl-tag">file:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"mover"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"moveInput"</span> 
            <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"output"</span>
            <span class="hl-attribute">directory</span>=<span class="hl-value">"${output.directory}"</span> 
            <span class="hl-attribute">delete-source-files</span>=<span class="hl-value">"true"</span>/&gt;</pre><p>
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			The 'outbound-gateway' works well in cases where you want to first move a File and then send it
			through a processing pipeline. In such cases, you may connect the file namespace's
			'inbound-channel-adapter' element to the 'outbound-gateway' and then connect that gateway's
			reply-channel to the beginning of the pipeline.
		</td></tr></tbody></table></div><p>
			If you have more elaborate requirements or need to support additional payload types as input
			to be converted to file content you could extend the FileWritingMessageHandler, but a much
			better option is to rely on a <code class="classname">Transformer</code>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="file-transforming"></a>17.4&nbsp;File Transformers</h2></div></div></div><p>
			To transform data read from the file system to objects and the other way around you need
			to do some work. Contrary to <code class="classname">FileReadingMessageSource</code> and to a
			lesser extent <code class="classname">FileWritingMessageHandler</code>, it is very likely that you
			will need your own mechanism to get the job done. For this you can implement the
			<code class="interfacename">Transformer</code> interface. Or extend the
			<code class="classname">AbstractFilePayloadTransformer</code> for inbound messages. Some obvious
			implementations have been provided.
		</p><p>
			<code class="classname">FileToByteArrayTransformer</code> transforms Files into byte[]s using
			Spring's <code class="classname">FileCopyUtils</code>. It is often better to use a sequence of
			transformers than to put all transformations in a single class. In that case the File to
			byte[] conversion might be a logical first step.
		</p><p>
			<code class="classname">FileToStringTransformer</code> will convert Files to Strings as the name
			suggests. If nothing else, this can be useful for debugging (consider using with a Wire Tap).
		</p><p>
			To configure File specific transformers you can use the appropriate elements from the file namespace.
			</p><pre class="programlisting"> &lt;<span class="hl-tag">file-to-bytes-transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
             <span class="hl-attribute">delete-files</span>=<span class="hl-value">"true"</span>/&gt;

 &lt;<span class="hl-tag">file:file-to-string-transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output
             delete-files="</span><span class="hl-attribute">true"</span> <span class="hl-attribute">charset</span>=<span class="hl-value">"UTF-8"</span>/&gt;</pre><p>
			The <span class="emphasis"><em>delete-files</em></span> option signals to the transformer that it should delete
			the inbound File after the transformation is complete. This is in no way a replacement for using the
			<code class="classname">AcceptOnceFileListFilter</code> when the FileReadingMessageSource is being used in a
			multi-threaded environment (e.g. Spring Integration in general).
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jms"></a>18.&nbsp;JMS Support</h2></div></div></div><p>
    Spring Integration provides Channel Adapters for receiving and sending JMS messages. There are actually two
    JMS-based inbound Channel Adapters. The first uses Spring's <code class="classname">JmsTemplate</code> to receive based on
    a polling period. The second is "message-driven" and relies upon a Spring MessageListener container. There is also
    an outbound Channel Adapter which uses the <code class="classname">JmsTemplate</code> to convert and send a JMS Message on
    demand.
  </p><p>
    Whereas the JMS Channel Adapters are intended for unidirectional Messaging (send-only or receive-only), Spring
    Integration also provides inbound and outbound JMS Gateways for request/reply operations. The inbound gateway
    relies on one of Spring's MessageListener container implementations for Message-driven reception that is also
    capable of sending a return value to the "reply-to" Destination as provided by the received Message. The outbound
    Gateway sends a JMS Message to a "request-destination" and then receives a reply Message. The "reply-destination"
    reference (or "reply-destination-name") can be configured explicitly or else the outbound gateway will use a
    JMS TemporaryQueue.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-inbound-channel-adapter"></a>18.1&nbsp;Inbound Channel Adapter</h2></div></div></div><p>
      The inbound Channel Adapter requires a reference to either a single <code class="classname">JmsTemplate</code>
      instance or both <code class="interfacename">ConnectionFactory</code> and <code class="interfacename">Destination</code>
      (a 'destinationName' can be provided in place of the 'destination' reference). The following example defines an
      inbound Channel Adapter with a <code class="classname">Destination</code> reference.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">jms:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsIn"</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"inQueue"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"exampleChannel"</span>&gt;
     &lt;<span class="hl-tag">integration:poller</span>&gt;
         &lt;<span class="hl-tag">integration:interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"30"</span> <span class="hl-attribute">time-unit</span>=<span class="hl-value">"SECONDS"</span>/&gt;
     &lt;<span class="hl-tag">/integration:poller</span>&gt;
 &lt;<span class="hl-tag">/jms:inbound-channel-adapter</span>&gt;</pre><p>
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
        Notice from the configuration that the inbound-channel-adapter is a Polling Consumer. That means that
        it invokes receive() when triggered. This should only be used in situations where polling is done relatively
        infrequently and timeliness is not important. For all other situations (a vast majority of JMS-based use-cases),
        the <span class="emphasis"><em>message-driven-channel-adapter</em></span> described below is a better option.
      </td></tr></tbody></table></div><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        All of the JMS adapters that require a reference to the ConnectionFactory will automatically look for
        a bean named "connectionFactory" by default. That is why you don't see a "connection-factory" attribute
        in many of the examples. However, if your JMS ConnectionFactory has a different bean name, then you will
        need to provide that attribute.
      </td></tr></tbody></table></div><p>
    </p><p>
      If 'extract-payload' is set to true (which is the default), the received JMS Message will be passed through
      the MessageConverter. When relying on the default SimpleMessageConverter, this means that the resulting Spring
      Integration Message will have the JMS Message's body as its payload. A JMS TextMessage will produce a
      String-based payload, a JMS BytesMessage will produce a byte array payload, and a JMS ObjectMessage's
      Serializable instance will become the Spring Integration Message's payload. If instead you prefer to have
      the raw JMS Message as the Spring Integration Message's payload, then set 'extract-payload' to false.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">jms:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsIn"</span>
                              <span class="hl-attribute">destination</span>=<span class="hl-value">"inQueue"</span>
                              <span class="hl-attribute">channel</span>=<span class="hl-value">"exampleChannel"</span>
                              <span class="hl-attribute">extract-payload</span>=<span class="hl-value">"false"</span>/&gt;
     &lt;<span class="hl-tag">integration:poller</span>&gt;
         &lt;<span class="hl-tag">integration:interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"30"</span> <span class="hl-attribute">time-unit</span>=<span class="hl-value">"SECONDS"</span>/&gt;
     &lt;<span class="hl-tag">/integration:poller</span>&gt;
 &lt;<span class="hl-tag">/jms:inbound-channel-adapter</span>&gt;</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-message-driven-channel-adapter"></a>18.2&nbsp;Message-Driven Channel Adapter</h2></div></div></div><p>
      The "message-driven-channel-adapter" requires a reference to either an instance of a Spring MessageListener
      container (any subclass of <code class="classname">AbstractMessageListenerContainer</code>) or both  
      <code class="interfacename">ConnectionFactory</code> and <code class="interfacename">Destination</code>
      (a 'destinationName' can be provided in place of the 'destination' reference). The following example defines a
      message-driven Channel Adapter with a <code class="classname">Destination</code> reference.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">jms:message-driven-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsIn"</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"inQueue"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"exampleChannel"</span>/&gt;</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        The Message-Driven adapter also accepts several properties that pertain to the MessageListener container.
        These values are only considered if you do not provide an actual 'container' reference. In that case,
        an instance of DefaultMessageListenerContainer will be created and configured based on these properties.
        For example, you can specify the "transaction-manager" reference, the "concurrent-consumers" value, and
        several other property references and values. Refer to the JavaDoc and Spring Integration's JMS Schema
        (spring-integration-jms-1.0.xsd) for more detail.
      </td></tr></tbody></table></div><p>
    </p><p>
      The 'extract-payload' property has the same effect as described above, and once again its default value
      is 'true'. The poller sub-element is not applicable for a message-driven
      Channel Adapter, as it will be actively invoked. For most usage scenarios, the message-driven approach is better since the Messages will
      be passed along to the <code class="interfacename">MessageChannel</code> as soon as they are received from the underlying
      JMS consumer.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-outbound-channel-adapter"></a>18.3&nbsp;Outbound Channel Adapter</h2></div></div></div><p>
      The <code class="classname">JmsSendingMessageHandler</code> implements the <code class="interfacename">MessageHandler</code>
      interface and is capable of converting Spring Integration <code class="interfacename">Messages</code> to JMS messages
      and then sending to a JMS destination. It requires either a 'jmsTemplate' reference or both 'connectionFactory' and
      'destination' references (again, the 'destinationName' may be provided in place of the 'destination'). As with the
      inbound Channel Adapter, the easiest way to configure this adapter is with the namespace support. The following
      configuration will produce an adapter that receives Spring Integration Messages from the "exampleChannel" and then
      converts those into JMS Messages and sends them to the JMS Destination reference whose bean name is "outQueue".
      </p><pre class="programlisting">&lt;<span class="hl-tag">jms:outbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsOut"</span> <span class="hl-attribute">destination</span>=<span class="hl-value">"outQueue"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"exampleChannel"</span>/&gt;</pre><p>
    </p><p>
      As with the inbound Channel Adapters, there is an 'extract-payload' property. However, the meaning is reversed
      for the outbound adapter. Rather than applying to the JMS Message, the boolean property applies to the Spring
      Integration Message payload. In other words, the decision is whether to pass the Spring Integration Message
      <span class="emphasis"><em>itself</em></span> as the JMS Message body or whether to pass the Spring Integration Message's
      payload as the JMS Message body. The default value is once again 'true'. Therefore, if you pass a Spring
      Integration Message whose payload is a String, a JMS TextMessage will be created. If on the other hand you
      want to send the actual Spring Integration Message to another system via JMS, then simply set this to 'false'.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        Regardless of the boolean value for payload extraction, the Spring Integration MessageHeaders will map to
        JMS properties as long as you are relying on the default converter or provide a reference to another
        instance of HeaderMappingMessageConverter (the same holds true for 'inbound' adapters except that in
        those cases, it's the JMS properties mapping <span class="emphasis"><em>to</em></span> Spring Integration MessageHeaders).
      </td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-inbound-gateway"></a>18.4&nbsp;Inbound Gateway</h2></div></div></div><p>
      Spring Integration's message-driven JMS inbound-gateway delegates to a
      <code class="interfacename">MessageListener</code> container, supports dynamically adjusting concurrent consumers,
      and can also handle replies. The inbound gateway requires references to a
      <code class="interfacename">ConnectionFactory</code>, and a request <code class="interfacename">Destination</code> (or
      'requestDestinationName'). The following example defines a JMS "inbound-gateway" that receives from the JMS
      queue referenced by the bean id "inQueue" and sends to the Spring Integration channel named "exampleChannel".
      </p><pre class="programlisting"> &lt;<span class="hl-tag">jms:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsInGateway"</span>
                      <span class="hl-attribute">request-destination</span>=<span class="hl-value">"inQueue"</span>
                      <span class="hl-attribute">request-channel</span>=<span class="hl-value">"exampleChannel"</span>/&gt;</pre><p>
    </p><p>
      Since the gateways provide request/reply behavior instead of unidirectional send <span class="emphasis"><em>or</em></span>
      receive, they also have two distinct properties for the "payload extraction" (as discussed above for the
      Channel Adapters' 'extract-payload' setting). For an inbound-gateway, the 'extract-request-payload' property
      determines whether the received JMS Message body will be extracted. If 'false', the JMS Message itself will
      become the Spring Integration Message payload. The default is 'true'.
    </p><p>
      Similarly, for an inbound-gateway the 'extract-reply-payload' property applies to the Spring Integration Message
      that is going to be converted into a reply JMS Message. If you want to pass the whole Spring Integration Message
      (as the body of a JMS ObjectMessage) then set this to 'false'. By default, it is also 'true' such that the Spring
      Integration Message <span class="emphasis"><em>payload</em></span> will be converted into a JMS Message (e.g. String payload
      becomes a JMS TextMessage).
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-outbound-gateway"></a>18.5&nbsp;Outbound Gateway</h2></div></div></div><p>
      The outbound Gateway creates JMS Messages from Spring Integration Messages and then sends to a
      'request-destination'. It will then handle the JMS reply Message either by using a selector to
      receive from the 'reply-destination' that you configure, or if no 'reply-destination' is provided,
      it will create JMS TemporaryQueues. Notice that the "reply-channel" is also provided.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">jms:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jmsOutGateway"</span>
                       <span class="hl-attribute">request-destination</span>=<span class="hl-value">"outQueue"</span>
                       <span class="hl-attribute">request-channel</span>=<span class="hl-value">"outboundJmsRequests"</span>
                       <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"jmsReplies"</span>/&gt;</pre><p>
    </p><p>
      The 'outbound-gateway' payload extraction properties are inversely related to those of the
      'inbound-gateway' (see the discussion above). That means that the 'extract-request-payload' property value
      applies to the Spring Integration Message that is being converted into a JMS Message to be
      <span class="emphasis"><em>sent as a request</em></span>, and the 'extract-reply-payload' property value applies to the
      JMS Message that is <span class="emphasis"><em>received as a reply</em></span> and then converted into a Spring Integration
      Message to be subsequently sent to the 'reply-channel' as shown in the example configuration above.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        For all of these JMS adapters, you can also specify your own "message-converter" reference. Simply provide the
        bean name of an instance of <code class="interfacename">MessageConverter</code> that is available within the same
        ApplicationContext. Note, however, that when you provide your own MessageConverter instance, it will still
        be wrapped within the HeaderMappingMessageConverter. This means that the 'extract-request-payload'
        and 'extract-reply-payload' properties may effect what actual objects are passed to your converter. The
        HeaderMappingMessageConverter itself simply delegates to a target MessageConverter while also mapping the
        Spring Integration MessageHeaders to JMS Message properties and vice-versa.
      </td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-samples"></a>18.6&nbsp;JMS Samples</h2></div></div></div><p>
      To experiment with these JMS adapters, check out the samples available within the "samples/jms" directory in
      the distribution. There are two samples included. One provides inbound and outbound Channel Adapters, and the
      other provides inbound and outbound Gateways. They are configured to run with an embedded ActiveMQ process, but
      the "common.xml" file can easily be modified to support either a different JMS provider or a standalone
      ActiveMQ process. In other words, you can split the configuration so that the inbound and outbound adapters are
      running in separate JVMs. If you have ActiveMQ installed, simply modify the "brokerURL" property within the
      configuration to use "tcp://localhost:61616" for example (instead of "vm://localhost"). Both of the samples
      accept input via stdin and then echo back to stdout. Look at the configuration to see how these messages are
      routed over JMS.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ws"></a>19.&nbsp;Web Services Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webservices-outbound"></a>19.1&nbsp;Outbound Web Service Gateways</h2></div></div></div><p>
      To invoke a Web Service upon sending a message to a channel, there are two options - both of which build
      upon the <a class="ulink" href="http://static.springframework.org/spring-ws/sites/1.5/" target="_top">Spring Web Services</a>
      project: <code class="classname">SimpleWebServiceOutboundGateway</code> and
      <code class="classname">MarshallingWebServiceOutboundGateway</code>. The former will accept either a
      <code class="classname">String</code> or <code class="interfacename">javax.xml.transform.Source</code> as the message
      payload. The latter provides support for any implementation of the <code class="interfacename">Marshaller</code>
      and <code class="interfacename">Unmarshaller</code> interfaces. Both require a Spring Web Services
      <code class="interfacename">DestinationProvider</code> for determining the URI of the Web Service to be
      called.</p><pre class="programlisting"> simpleGateway = <span class="hl-keyword">new</span> SimpleWebServiceOutboundGateway(destinationProvider);

 marshallingGateway = <span class="hl-keyword">new</span> MarshallingWebServiceOutboundGateway(destinationProvider, marshaller);
</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
	    When using the namespace support described below, you will only need to set a URI. Internally, the parser
	    will configure a fixed URI DestinationProvider implementation. If you do need dynamic resolution of the
		URI at runtime, however, then the DestinationProvider can provide such behavior as looking up the URI from
		a registry. See the Spring Web Services
		<a class="ulink" href="http://static.springsource.org/spring-ws/sites/1.5/apidocs/index.html" target="_top">javadoc</a> for
		more information about the DestinationProvider strategy.
	  </td></tr></tbody></table></div><p>
    </p><p>
      For more detail on the inner workings, see the Spring Web Services reference guide's chapter covering 
      <a class="ulink" href="http://static.springframework.org/spring-ws/site/reference/html/client.html" target="_top">client access</a>
      as well as the chapter covering 
      <a class="ulink" href="http://static.springframework.org/spring-ws/site/reference/html/oxm.html" target="_top">Object/XML mapping</a>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webservices-inbound"></a>19.2&nbsp;Inbound Web Service Gateways</h2></div></div></div><p>
      To send a message to a channel upon receiving a Web Service invocation, there are two options again: <code class="classname">SimpleWebServiceInboundGateway</code> and
      <code class="classname">MarshallingWebServiceInboundGateway</code>. The former will extract a <code class="interfacename">javax.xml.transform.Source</code> 
      from the <code class="classname">WebServiceMessage</code> and set it as the message
      payload. The latter provides support for implementation of the <code class="interfacename">Marshaller</code>
      and <code class="interfacename">Unmarshaller</code> interfaces. 
      If the incoming web service message is a SOAP message the SOAP Action header will be added to the headers of the 
      <code class="classname">Message</code> that is forwarded onto the request channel.
      
      </p><pre class="programlisting"> simpleGateway = <span class="hl-keyword">new</span> SimpleWebServiceInboundGateway();
 simpleGateway.setRequestChannel(forwardOntoThisChannel);
 simpleGateway.setReplyChannel(listenForResponseHere); <span class="hl-comment">//Optional</span>

 marshallingGateway = <span class="hl-keyword">new</span> MarshallingWebServiceInboundGateway(marshaller);
 <span class="hl-comment">//set request and optionally reply channel</span>
</pre><p>
Both gateways implement the Spring Web Services <code class="interfacename">MessageEndpoint</code>
interface, so they can be configured with a <code class="classname">MessageDispatcherServlet</code> 
as per standard Spring Web Services configuration.
    </p><p>
      For more detail on how to use these components, see the Spring Web Services reference guide's chapter covering 
      <a class="ulink" href="http://static.springframework.org/spring-ws/sites/1.5/reference/html/server.html" target="_top">creating a Web Service</a>.
      The chapter covering 
      <a class="ulink" href="http://static.springframework.org/spring-ws/site/reference/html/oxm.html" target="_top">Object/XML mapping</a> is also applicable again.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webservices-namespace"></a>19.3&nbsp;Web Service Namespace Support</h2></div></div></div><p>
      To configure an outbound Web Service Gateway, use the "outbound-gateway" element from the "ws" namespace:
      </p><pre class="programlisting">&lt;<span class="hl-tag">ws:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"simpleGateway"</span>
                     <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputChannel"</span>
                     <span class="hl-attribute">uri</span>=<span class="hl-value">"http://example.org"</span>/&gt;</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
	    Notice that this example does not provide a 'reply-channel'. If the Web Service were to
	  	return a non-empty response, the Message containing that response would be sent to the
		reply channel provided in the request Message's REPLY_CHANNEL header, and if that were
		not available a channel resolution Exception would be thrown. If you want to send the
		reply to another channel instead, then provide a 'reply-channel' attribute on the
		'outbound-gateway' element.
	  </td></tr></tbody></table></div><p>
	  </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
		When invoking a Web Service that returns an empty response after using a String payload
		for the request Message, <span class="emphasis"><em>no reply Message will be sent by default</em></span>.
		Therefore you don't need to set a 'reply-channel' or have a REPLY_CHANNEL header in the
		request Message. If for any reason you actually <span class="emphasis"><em>do</em></span> want to receive
		the empty response as a Message, then provide the 'ignore-empty-responses' attribute with
		a value of <span class="emphasis"><em>false</em></span> (this only applies for Strings, because using a 
		Source or Document object simply leads to a NULL response and will therefore
		<span class="emphasis"><em>never</em></span> generate a reply Message).
	  </td></tr></tbody></table></div><p>

      To set up an inbound Web Service Gateway, use the "inbound-gateway":
      </p><pre class="programlisting">&lt;<span class="hl-tag">ws:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"simpleGateway"</span>
                    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"inputChannel"</span>/&gt;</pre><p>
                    
      To use Spring OXM Marshallers and/or Unmarshallers, provide bean references. For outbound:
      </p><pre class="programlisting">&lt;<span class="hl-tag">ws:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"marshallingGateway"</span>
                     <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requestChannel"</span>
                     <span class="hl-attribute">uri</span>=<span class="hl-value">"http://example.org"</span>
                     <span class="hl-attribute">marshaller</span>=<span class="hl-value">"someMarshaller"</span>
                     <span class="hl-attribute">unmarshaller</span>=<span class="hl-value">"someUnmarshaller"</span>/&gt;</pre><p>
      And for inbound:
      </p><pre class="programlisting">&lt;<span class="hl-tag">ws:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"marshallingGateway"</span>
                    <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requestChannel"</span>
                    <span class="hl-attribute">marshaller</span>=<span class="hl-value">"someMarshaller"</span>
                    <span class="hl-attribute">unmarshaller</span>=<span class="hl-value">"someUnmarshaller"</span>/&gt;</pre><p>

      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        Most <code class="interfacename">Marshaller</code> implementations also implement the
        <code class="interfacename">Unmarshaller</code> interface. When using such a 
		<code class="interfacename">Marshaller</code>, only the "marshaller"
        attribute is necessary. Even when using a <code class="interfacename">Marshaller</code>, 
        you may also provide a reference for the "request-callback" on the outbound gateways.
      </td></tr></tbody></table></div><p>
    </p><p>
	  For either outbound gateway type, a "destination-provider" attribute can be specified instead of the "uri"
	  (exactly one of them is required). You can then reference any Spring Web Services DestinationProvider
	  implementation (e.g. to lookup the URI at runtime from a registry).
	</p><p>
      For either outbound gateway type, the "message-factory" attribute can also be configured with a reference to any
      Spring Web Services <code class="interfacename">WebServiceMessageFactory</code> implementation.
    </p><p>
      For the simple inbound gateway type, the "extract-payload" attribute can be set to false to forward
      the entire <code class="interfacename">WebServiceMessage</code> instead of just its payload as a        
      <code class="interfacename">Message</code> to the request channel. This might be useful, for example,
      when a custom Transformer works against the <code class="interfacename">WebServiceMessage</code> directly.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="rmi"></a>20.&nbsp;RMI Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rmi-intro"></a>20.1&nbsp;Introduction</h2></div></div></div><p>
		This Chapter explains how to use RMI specific channel adapters to distribute a system over multiple JVMs. The first section will deal with sending messages over RMI. The second section shows how to receive messages over RMI. The last section shows how to define rmi channel adapters through the namespace support.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rmi-outbound"></a>20.2&nbsp;Outbound RMI</h2></div></div></div><p>
		To send messages from a channel over RMI, simply define an <code class="classname">RmiOutboundGateway</code>. This gateway will use Spring's RmiProxyFactoryBean internally to create a proxy for a remote gateway. Note that to invoke a remote interface that doesn't use Spring Integration you should use a service activator in combination with Spring's RmiProxyFactoryBean.
	</p><p>
		To configure the outbound gateway write a bean definition like this:
		</p><pre class="programlisting">	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rmiOutGateway"</span> <span class="hl-attribute">class</span>=<span class="hl-value">org.spf.integration.rmi.RmiOutboundGateway</span>&gt;
		&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"rmi://host"</span>/&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"replyChannel"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"replies"</span>/&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;
	</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rmi-inbound"></a>20.3&nbsp;Inbound RMI</h2></div></div></div><p>
		To receive messages over RMI you need to use a <code class="classname">RmiInboundGateway</code>. This gateway can be configured like this
		</p><pre class="programlisting"> &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"rmiOutGateway"</span> <span class="hl-attribute">class</span>=<span class="hl-value">org.spf.integration.rmi.RmiInboundGateway</span>&gt;
     &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"requestChannel"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"requests"</span>/&gt;
 &lt;<span class="hl-tag">/bean</span>&gt;
		</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rmi-namespace"></a>20.4&nbsp;RMI namespace support</h2></div></div></div><p>
		To configure the inbound gateway you can choose to use the namespace support for it. The following code snippet shows the different configuration options that are supported.
		</p><pre class="programlisting"> &lt;<span class="hl-tag">rmi:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"gatewayWithDefaults"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"testChannel"</span>/&gt;

 &lt;<span class="hl-tag">rmi:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"gatewayWithCustomProperties"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"testChannel"</span>
                      <span class="hl-attribute">expect-reply</span>=<span class="hl-value">"false"</span> <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"123"</span> <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"456"</span>/&gt;

 &lt;<span class="hl-tag">rmi:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"gatewayWithHost"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"testChannel"</span>
                      <span class="hl-attribute">registry-host</span>=<span class="hl-value">"localhost"</span>/&gt;

 &lt;<span class="hl-tag">rmi:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"gatewayWithPort"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"testChannel"</span>
                      <span class="hl-attribute">registry-port</span>=<span class="hl-value">"1234"</span>/&gt;

 &lt;<span class="hl-tag">rmi:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"gatewayWithExecutorRef"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"testChannel"</span>
                      <span class="hl-attribute">remote-invocation-executor</span>=<span class="hl-value">"invocationExecutor"</span>/&gt;</pre><p>
    </p><p>
		To configure the outbound gateway you can use the namespace support as well. The following code snippet shows the different configuration for an outbound rmi gateway.
		</p><pre class="programlisting"> &lt;<span class="hl-tag">rmi:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"gateway"</span>
                       <span class="hl-attribute">request-channel</span>=<span class="hl-value">"localChannel"</span>
                       <span class="hl-attribute">remote-channel</span>=<span class="hl-value">"testChannel"</span>
                       <span class="hl-attribute">host</span>=<span class="hl-value">"localhost"</span>/&gt;</pre><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="httpinvoker"></a>21.&nbsp;HttpInvoker Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="httpinvoker-intro"></a>21.1&nbsp;Introduction</h2></div></div></div><p>
      HttpInvoker is a Spring-specific remoting option that essentially enables Remote Procedure Calls (RPC) over HTTP.
      In order to accomplish this, an outbound representation of a method invocation is serialized using standard Java
      serialization and then passed within an HTTP POST request. After being invoked on the target system, the method's
      return value is then serialized and written to the HTTP response. There are two main requirements. First, you
      must be using Spring on both sides since the marshalling to and from HTTP requests and responses is handled by
      the client-side invoker and server-side exporter. Second, the Objects that you are passing must implement
      <code class="interfacename">Serializable</code> and be available on both the client and server.
    </p><p>
      While traditional RPC provides <span class="emphasis"><em>physical</em></span> decoupling, it does not offer nearly the same degree
      of <span class="emphasis"><em>logical</em></span> decoupling as a messaging-based system. In other words, both participants in an
      RPC-based invocation must be aware of a specific interface and specific argument types. Interestingly, in Spring
      Integration, the "parameter" being sent is a Spring Integration Message, and the interface is an internal detail
      of Spring Integration's implementation. Therefore, the RPC mechanism is being used as a
      <span class="emphasis"><em>transport</em></span> so that from the end user's perspective, it is not necessary to consider the
      interface and argument types. It's just another adapter to enable messaging between two systems.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="httpinvoker-inbound"></a>21.2&nbsp;HttpInvoker Inbound Gateway</h2></div></div></div><p>
		To receive messages over http you can use an <code class="classname">HttpInvokerInboundGateway</code>. Here is an
		example bean definition:
		</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inboundGateway"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.httpinvoker.HttpInvokerInboundGateway"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"requestChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"requestChannel"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"replyChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"replyChannel"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"requestTimeout"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"30000"</span>/&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"replyTimeout"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10000"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
		Because the inbound gateway must be able to receive HTTP requests, it must be configured within a Servlet
		container. The easiest way to do this is to provide a servlet definition in <span class="emphasis"><em>web.xml</em></span>:
		</p><pre class="programlisting">&lt;<span class="hl-tag">servlet</span>&gt;
    &lt;<span class="hl-tag">servlet-name</span>&gt;inboundGateway&lt;<span class="hl-tag">/servlet-name</span>&gt;
    &lt;<span class="hl-tag">servlet-class</span>&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;<span class="hl-tag">/servlet-class</span>&gt;
&lt;<span class="hl-tag">/servlet</span>&gt;</pre><p>
		Notice that the servlet name matches the bean name.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			If you are running within a Spring MVC application and using the BeanNameHandlerMapping, then the servlet
			definition is not necessary. In that case, the bean name for your gateway can be matched against the URL
			path just like a Spring MVC Controller bean.
		</td></tr></tbody></table></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="httpinvoker-outbound"></a>21.3&nbsp;HttpInvoker Outbound Gateway</h2></div></div></div><p>
	</p><p>
		To configure the <code class="classname">HttpInvokerOutboundGateway</code> write a bean definition like this:
		</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outboundGateway"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.httpinvoker.HttpInvokerOutboundGateway"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"replyChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"replyChannel"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
		The outbound gateway is a <code class="interfacename">MessageHandler</code> and can therefore be registered with
		either a <code class="classname">PollingConsumer</code> or <code class="classname">EventDrivenConsumer</code>.
		The URL must match that defined by an inbound HttpInvoker Gateway as described in the previous section.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="httpinvoker-namespace"></a>21.4&nbsp;HttpInvoker Namespace Support</h2></div></div></div><p>
		Spring Integration provides an "httpinvoker" namespace and schema definition. To include it in your
		configuration, simply provide the following URI within a namespace declaration:
		'http://www.springframework.org/schema/integration/httpinvoker'. The schema location should then map to
		'http://www.springframework.org/schema/integration/httpinvoker/spring-integration-httpinvoker-1.0.xsd'.
	</p><p>
		To configure the inbound gateway you can choose to use the namespace support for it. The following code snippet shows the different configuration options that are supported.
		</p><pre class="programlisting">&lt;<span class="hl-tag">httpinvoker:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inboundGateway"</span>
                             <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requestChannel"</span>
                             <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"10000"</span> 
                             <span class="hl-attribute">expect-reply</span>=<span class="hl-value">"false"</span>
                             <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"30000"</span>/&gt;</pre><p>
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			A 'reply-channel' may also be provided, but it is recommended to rely on the temporary anonymous channel
			that will be created automatically for handling replies.
		</td></tr></tbody></table></div><p>
    </p><p>
		To configure the outbound gateway you can use the namespace support as well. The following code snippet shows the different configuration for an outbound HttpInvoker gateway. Only the 'url' and 'request-channel' are required.
		</p><pre class="programlisting">&lt;<span class="hl-tag">httpinvoker:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"outboundGateway"</span>
                              <span class="hl-attribute">url</span>=<span class="hl-value">"http://localhost:8080/example"</span>
                              <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requestChannel"</span>
                              <span class="hl-attribute">request-timeout</span>=<span class="hl-value">"5000"</span>
                              <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"replyChannel"</span>
                              <span class="hl-attribute">reply-timeout</span>=<span class="hl-value">"10000"</span>/&gt;</pre><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="http"></a>22.&nbsp;HTTP Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="http-intro"></a>22.1&nbsp;Introduction</h2></div></div></div><p>
      The HTTP support allows for the making of HTTP requests and the processing of inbound Http requests.  Because interaction over HTTP is always synchronous, even if all that is returned is a 200 status code the Http support consists of two gateway implementations
 	<code class="classname">HttpInboundEndpoint</code> and <code class="classname">HttpOutboundEndpoint</code>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="http-inbound"></a>22.2&nbsp;Http Inbound Gateway</h2></div></div></div><p>
		To receive messages over http you need to use an <code class="classname">HttpInboundEndpoint</code>.  In common with the HttpInvoker 
	support the Http Inbound Gateway needs to be deployed within a servlet container.  The easiest way to do this is to provide a servlet 
	definition in <span class="emphasis"><em>web.xml</em></span>, see 
	<a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#httpinvoker-inbound" title="21.2Â HttpInvoker Inbound Gateway">Section&nbsp;21.2, âHttpInvoker Inbound Gatewayâ</a> for further details.  Below is an example bean definition for a simple <code class="classname">HttpInboundEndpoint</code>	
		</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpInbound"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.http.HttpInboundEndpoint"</span>&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"requestChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"httpRequestChannel"</span> /&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"replyChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"httpReplyChannel"</span> /&gt;	
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
	The <code class="classname">HttpInboundEndpoint</code> accepts an instance of <code class="interfacename">InboundRequestMapper</code> which allows 
	customisation of the mapping from <code class="interfacename">HttpServletRequest</code> to <code class="interfacename">Message</code>.  If none is 
	provided an instance of <code class="classname">DefaultInboundRequestMapper</code> will be used.  This encapsulates a simple strategy, which for
	example will create a String message for a <span class="emphasis"><em>POST</em></span> request where the content type starts with "text", see the Javadoc for 
	full details.   		
      </p><p>Starting with this release MultiPart File support was implemented. If the request has been wrapped as a
	  <span class="emphasis"><em>MultipartHttpServletRequest</em></span>, then the 'content type' can be checked. If it is known, and
	  begins with "text", then the <span class="emphasis"><em>MultipartFile</em></span> will be copied to a String in the parameter
	  map. If the content type does not begin with "text", then the <span class="emphasis"><em>MultipartFile</em></span> will be copied
	  to a byte array within the parameter map instead.
	  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
		The HttpInboundEndpoint will locate a MultipartResolver in the context if one exists with the bean name
		"multipartResolver" (the same name expected by Spring's DispatcherServlet). If it does in fact locate that
		bean, then the support for MultipartFiles will be enabled on the inbound request mapper. Otherwise, it will
		fail when trying to map a multipart-file request to a Spring Integration Message. For more on Spring's
		support for MultipartResolvers, refer to the <a class="ulink" href="http://static.springsource.org/spring/docs/2.5.x/reference/mvc.html#mvc-multipart" target="_top">Spring Reference Manual</a>.
      </td></tr></tbody></table></div><p>
      </p><p>
		In sending a response to the client there are a number of ways to customise the behaviour of the gateway.  By default the gateway will 
	simply acknowledge that the request was received by sending a 200 status code back.  It is possible to customise this response by providing an 
	implementation of the Spring MVC <code class="interfacename">View</code> which will be invoked with the created <code class="interfacename">Message</code>.  
        In the case that the gateway should expect a reply to the <code class="interfacename">Message</code> then setting the <span class="property">expectReply</span> flag will cause 
	the gateway to wait for a response <code class="interfacename">Message</code> before creating an Http response.  Below is an example of a gateway 
	configured to use a custom view and to wait for a response.  It also shows how to customise the Http methods accepted by the gateway, which 
	are <span class="emphasis"><em>POST</em></span> and <span class="emphasis"><em>GET</em></span> by default.    
	</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpInbound"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.http.HttpInboundEndpoint"</span>&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"requestChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"httpRequestChannel"</span> /&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"replyChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"httpReplyChannel"</span> /&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"view"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"jsonView"</span> /&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"supportedMethods"</span> &gt;
		&lt;<span class="hl-tag">list</span>&gt;
			&lt;<span class="hl-tag">value</span>&gt;GET&lt;<span class="hl-tag">/value</span>&gt;
			&lt;<span class="hl-tag">value</span>&gt;DELETE&lt;<span class="hl-tag">/value</span>&gt;
		&lt;<span class="hl-tag">/list</span>&gt;
	&lt;<span class="hl-tag">/property</span>&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"expectReply"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span> /&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"requestMapper"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customRequestMapper"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
	The message created from the request will be available in the Model map. The key that is used
	for that map entry by default is 'requestMessage', but this can be overridden by setting the
	'requestKey' property on the endpoint's configuration.
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="http-outbound"></a>22.3&nbsp;Http Outbound Gateway</h2></div></div></div><p>
		To configure the <code class="classname">HttpOutboundEndpoint</code> write a bean definition like this:
		</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpOutbound"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.http.HttpOutboundEndpoint"</span> &gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"outputChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"responseChannel"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
		This bean definition will execute Http requests by first converting the message to the Http request using an instance of 
		<code class="classname">DefaultOutboundRequestMapper</code>.  This will expect to find the request URL in the message header under 
		the key <span class="emphasis"><em>HttpHeaders.REQUEST_URL</em></span>.  It is also possible to set a default target URL as a constructor argument 
		along with other options as shown below.
		</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpOutbound"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.http.HttpOutboundEndpoint"</span> &gt;
	&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"http://localhost:8080/example"</span> /&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"outputChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"responseChannel"</span> /&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sendTimeout"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5000"</span> /&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"requestMapper"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customRequestMapper"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
By default the Http request will be made using an instance of <code class="classname">SimpleHttpRequestExecutor</code> which uses the JDK 
	<code class="classname">HttpURLConnection</code>.  Use of the Apache Commons Http Client is also supported through the provided 
	<code class="classname">CommonsHttpRequestExecutor</code> which can be injected into the outbound gateway.   	
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="http-namespace"></a>22.4&nbsp;Http Namespace Support</h2></div></div></div><p>
		Spring Integration provides an "http" namespace and schema definition. To include it in your
		configuration, simply provide the following URI within a namespace declaration:
		'http://www.springframework.org/schema/integration/http'. The schema location should then map to
		'http://www.springframework.org/schema/integration/http/spring-integration-http-1.0.xsd'.
	</p><p>
		To configure an inbound http channel adapter which is an instance of <code class="classname">HttpInboundEndpoint</code> configured 
		not to expect a response.
		</p><pre class="programlisting"> &lt;<span class="hl-tag">http:inbound-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"httpChannelAdapter"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"requests"</span> <span class="hl-attribute">supported-methods</span>=<span class="hl-value">"PUT, DELETE"</span>/&gt;</pre><p>
    </p><p>
		To configure an inbound http gateway which expects a response.
		</p><pre class="programlisting"> &lt;<span class="hl-tag">http:inbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"inboundGateway"</span> <span class="hl-attribute">request-channel</span>=<span class="hl-value">"requests"</span> <span class="hl-attribute">reply-channel</span>=<span class="hl-value">"responses"</span>/&gt;</pre><p>
    </p><p>
		To configure the outbound gateway you can use the namespace support as well. The following code snippet shows the different configuration options for an outbound Http gateway.
		</p><pre class="programlisting">&lt;<span class="hl-tag">http:outbound-gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"fullConfigWithoutMapper"</span>
		<span class="hl-attribute">request-channel</span>=<span class="hl-value">"requests"</span>
		<span class="hl-attribute">default-url</span>=<span class="hl-value">"http://localhost/test"</span>
		<span class="hl-attribute">extract-request-payload</span>=<span class="hl-value">"false"</span>
		<span class="hl-attribute">charset</span>=<span class="hl-value">"UTF-8"</span>
		<span class="hl-attribute">request-executor</span>=<span class="hl-value">"executor"</span>
		<span class="hl-attribute">request-timeout</span>=<span class="hl-value">"1234"</span>
		<span class="hl-attribute">reply-channel</span>=<span class="hl-value">"replies"</span>/&gt;</pre><p>
		If you want to provide a custom OutboundRequestMapper, then a reference may be supplied to the
		'request-mapper' attribute. In that case however you will not be allowed to set the default URL,
		charset, and 'extract-request-payload' properties since those are all properties of the default
		mapper (see the JavaDoc for DefaultOutboundRequestMapper for more information).
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mail"></a>23.&nbsp;Mail Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-outbound"></a>23.1&nbsp;Mail-Sending Channel Adapter</h2></div></div></div><p>
      Spring Integration provides support for outbound email with the
      <code class="classname">MailSendingMessageHandler</code>. It delegates to a configured instance of Spring's
      <code class="interfacename">JavaMailSender</code>:
      </p><pre class="programlisting"> JavaMailSender mailSender = (JavaMailSender) context.getBean(<span class="hl-string">"mailSender"</span>);

 MailSendingMessageHandler mailSendingHandler = <span class="hl-keyword">new</span> MailSendingMessageHandler(mailSender);</pre><p>
      <code class="classname">MailSendingMessageHandler</code> has various mapping strategies that use Spring's
      <code class="interfacename">MailMessage</code> abstraction. If the received Message's payload is already
      a MailMessage instance, it will be sent directly. Therefore, it is generally recommended to precede this
      consumer with a Transformer for non-trivial MailMessage construction requirements. However, a few simple
      Message mapping strategies are supported out-of-the-box. For example, if the message payload is a byte array,
      then that will be mapped to an attachment. If the payload is neither a MailMessage or byte array, then a
      MailMessage will be created with text content corresponding to the value returned from the Spring Integration
      Message payload's <code class="methodname">toString()</code> method. For simple text-based emails, simply provide a
      String-based Message payload.
    </p><p>
      The outbound MailMessage may also be configured with certain values from the
      <code class="classname">MessageHeaders</code>. If available, values will be mapped to the outbound mail's
      properties, such as the recipients (TO, CC, and BCC), the from/reply-to, and the subject. The header names are
      defined by the following constants:
      </p><pre class="programlisting"> MailHeaders.SUBJECT
 MailHeaders.TO
 MailHeaders.CC
 MailHeaders.BCC
 MailHeaders.FROM
 MailHeaders.REPLY_TO</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-inbound"></a>23.2&nbsp;Mail-Receiving Channel Adapter</h2></div></div></div><p>
      Spring Integration also provides support for inbound email with the
      <code class="classname">MailReceivingMessageSource</code>. It delegates to a configured instance of Spring
      Integration's own <code class="interfacename">MailReceiver</code> interface, and there are two implementations:
      <code class="classname">Pop3MailReceiver</code> and <code class="classname">ImapMailReceiver</code>. The easiest way to
      instantiate either of these is by passing the 'uri' for a Mail store to the receiver's constructor. For example:
      </p><pre class="programlisting"> MailReceiver receiver = <span class="hl-keyword">new</span> Pop3MailReceiver(<span class="hl-string">"pop3://usr:pwd@localhost/INBOX"</span>);
</pre><p>
    </p><p>
      Another option for receiving mail is the IMAP "idle" command (if supported by the mail server you are using).
      Spring Integration provides the <code class="classname">ImapIdleChannelAdapter</code> which is itself a Message-producing
      endpoint. It delegates to an instance of the <code class="classname">ImapMailReceiver</code> but enables asynchronous
      reception of Mail Messages. There are examples in the next section of configuring both types of inbound Channel
      Adapter with Spring Integration's namespace support in the 'mail' schema.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-namespace"></a>23.3&nbsp;Mail Namespace Support</h2></div></div></div><p>
      Spring Integration provides a namespace for mail-related configuration. To use it, configure the following schema
      locations.</p><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:mail</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/mail"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/integration/mail
            http://www.springframework.org/schema/integration/mail/spring-integration-mail-1.0.xsd"</span>&gt;</pre><p>
    </p><p>
      To configure an outbound Channel Adapter, provide the channel to receive from, and the MailSender:
      </p><pre class="programlisting">&lt;<span class="hl-tag">mail:outbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"outboundMail"</span>
                              <span class="hl-attribute">mail-sender</span>=<span class="hl-value">"mailSender"</span>/&gt;</pre><p>
      Alternatively, provide the host, username, and password:
      </p><pre class="programlisting">&lt;<span class="hl-tag">mail:outbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"outboundMail"</span>
                              <span class="hl-attribute">host</span>=<span class="hl-value">"somehost"</span> <span class="hl-attribute">username</span>=<span class="hl-value">"someuser"</span> <span class="hl-attribute">password</span>=<span class="hl-value">"somepassword"</span>/&gt;</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        Keep in mind, as with any outbound Channel Adapter, if the referenced channel is a PollableChannel, a
        &lt;poller&gt; sub-element should be provided with either an interval-trigger or cron-trigger.
      </td></tr></tbody></table></div><p>
    </p><p>
      To configure an inbound Channel Adapter, you have the choice between polling or event-driven (assuming your
      mail server supports IMAP IDLE - if not, then polling is the only option). A polling Channel Adapter simply
      requires the store URI and the channel to send inbound Messages to. The URI may begin with "pop3" or "imap":
      </p><pre class="programlisting"> &lt;<span class="hl-tag">mail:inbound-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"mailIn"</span>
                               <span class="hl-attribute">store-uri</span>=<span class="hl-value">"imap://usr:pwd@imap.example.com/INBOX"</span>&gt;
     &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">max-messages-per-poll</span>=<span class="hl-value">"3"</span>&gt;
         &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"30"</span> <span class="hl-attribute">time-unit</span>=<span class="hl-value">"SECONDS"</span>/&gt;
     &lt;<span class="hl-tag">/poller</span>&gt;
 &lt;<span class="hl-tag">/mail:inbound-channel-adapter</span>&gt;</pre><p>
      If you do have IMAP idle support, then you may want to configure the "imap-idle-channel-adapter" element instead.
      Since the "idle" command enables event-driven notifications, no poller is necessary for this adapter. It will
      send a Message to the specified channel as soon as it receives the notification that new mail is available:
      </p><pre class="programlisting"> &lt;<span class="hl-tag">mail:imap-idle-channel-adapter</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"mailIn"</span>
                                 <span class="hl-attribute">store-uri</span>=<span class="hl-value">"imaps://usr:pwd@imap.example.com:993/INBOX"</span>/&gt;</pre><p>
    </p><p>
      When using the namespace support, a <span class="emphasis"><em>header-enricher</em></span> Message Transformer is also available.
      This simplifies the application of the headers mentioned above to any Message prior to sending to the
      Mail-sending Channel Adapter.
      </p><pre class="programlisting">&lt;<span class="hl-tag">mail:header-enricher</span> <span class="hl-attribute">subject</span>=<span class="hl-value">"Example Mail"</span>
                     <span class="hl-attribute">to</span>=<span class="hl-value">"to@example.org"</span>
                     <span class="hl-attribute">cc</span>=<span class="hl-value">"cc@example.org"</span>
                     <span class="hl-attribute">bcc</span>=<span class="hl-value">"bcc@example.org"</span>
                     <span class="hl-attribute">from</span>=<span class="hl-value">"from@example.org"</span>
                     <span class="hl-attribute">reply-to</span>=<span class="hl-value">"replyTo@example.org"</span>
                     <span class="hl-attribute">overwrite</span>=<span class="hl-value">"false"</span>/&gt;</pre><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="stream"></a>24.&nbsp;Stream Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stream-intro"></a>24.1&nbsp;Introduction</h2></div></div></div><p>
		In many cases application data is obtained from a stream. It is <span class="emphasis"><em>not</em></span> recommended to send a reference to a Stream as a message payload to a consumer. Instead messages are created from data that is read from an input stream and message payloads are written to an output stream one by one.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stream-reading"></a>24.2&nbsp;Reading from streams</h2></div></div></div><p>
    Spring Integration provides two adapters for streams. Both <code class="classname">ByteStreamReadingMessageSource</code> and
    <code class="classname">CharacterStreamReadingMessageSource</code> implement <code class="interfacename">MessageSource</code>. 
	By configuring one of these within a channel-adapter element, the polling period can be configured,
    and the Message Bus can automatically detect and schedule them. The byte stream version requires an
    <code class="classname">InputStream</code>, and the character stream version requires a <code class="classname">Reader</code> as
    the single constructor argument. The <code class="classname">ByteStreamReadingMessageSource</code> also accepts the 'bytesPerMessage'
    property to determine how many bytes it will attempt to read into each <code class="interfacename">Message</code>. The 
	default value is 1024
		</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.stream.ByteStreamReadingMessageSource"</span>&gt;
	&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someInputStream"</span>/&gt;
	&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bytesPerMessage"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2048"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.stream.CharacterStreamReadingMessageSource"</span>&gt;
	&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someReader"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
		</pre><p>
  </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stream-writing"></a>24.3&nbsp;Writing to streams</h2></div></div></div><p>
		For target streams, there are also two implementations: <code class="classname">ByteStreamWritingMessageHandler</code> and
	    <code class="classname">CharacterStreamWritingMessageHandler</code>. Each requires a single constructor argument -
	    <code class="classname">OutputStream</code> for byte streams or <code class="classname">Writer</code> for character streams,
	    and each provides a second constructor that adds the optional 'bufferSize'. Since both of these
	    ultimately implement the <code class="interfacename">MessageHandler</code> interface, they can be referenced from a
	    <span class="emphasis"><em>channel-adapter</em></span> configuration as described in more detail in
	    <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#channel-adapter" title="6.Â Channel Adapter">Chapter&nbsp;6, <i>Channel Adapter</i></a>.
		</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.stream.ByteStreamWritingMessageHandler"</span>&gt;
	&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someOutputStream"</span>/&gt;
	&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1024"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.stream.CharacterStreamWritingMessageHandler"</span>&gt;
	&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"someWriter"</span>/&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
	</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stream-namespace"></a>24.4&nbsp;Stream namespace support</h2></div></div></div><p>
		To reduce the configuration needed for stream related channel adapters there is a namespace defined. The following schema locations are needed to use it.
		</p><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">beans:beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/stream"</span>
	<span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="hl-attribute">xmlns:beans</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
	<span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
			http://www.springframework.org/schema/integration/stream
			http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd"</span>&gt;</pre><p>
	</p><p>
		To configure the inbound channel adapter the following code snippet shows the different configuration options that are supported.
		</p><pre class="programlisting">&lt;<span class="hl-tag">stdin-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"adapterWithDefaultCharset"</span>/&gt;

&lt;<span class="hl-tag">stdin-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"adapterWithProvidedCharset"</span> <span class="hl-attribute">charset</span>=<span class="hl-value">"UTF-8"</span>/&gt;</pre><p>
    </p><p>
		To configure the outbound channel adapter you can use the namespace support as well. The following code snippet shows the different configuration for an outbound channel adapters.
		</p><pre class="programlisting">&lt;<span class="hl-tag">stdout-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"stdoutAdapterWithDefaultCharset"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"testChannel"</span>/&gt;

&lt;<span class="hl-tag">stdout-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"stdoutAdapterWithProvidedCharset"</span> <span class="hl-attribute">charset</span>=<span class="hl-value">"UTF-8"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"testChannel"</span>/&gt;

&lt;<span class="hl-tag">stderr-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"stderrAdapter"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"testChannel"</span>/&gt;

&lt;<span class="hl-tag">stdout-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"newlineAdapter"</span> <span class="hl-attribute">append-newline</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">channel</span>=<span class="hl-value">"testChannel"</span>/&gt;
		</pre><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="applicationevent"></a>25.&nbsp;Spring ApplicationEvent Support</h2></div></div></div><p>
    Spring Integration provides support for inbound and outbound <code class="classname">ApplicationEvents</code>
    as defined by the underlying Spring Framework. For more information about the events and listeners,
    refer to the  <a class="ulink" href="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html#context-functionality-events" target="_top">Spring Reference Manual</a>.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="applicationevent-inbound"></a>25.1&nbsp;Receiving Spring ApplicationEvents</h2></div></div></div><p>
		To receive events and send them to a channel, simply define an instance of Spring Integration's
		<code class="classname">ApplicationEventListeningChannelAdapter</code>. This class is an implementation of
		Spring's <code class="interfacename">ApplicationListener</code> interface. By default it will pass all
		received events as Spring Integration Messages. To limit based on the type of event, configure the
		list of event types that you want to receive with the 'eventTypes' property.
	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="applicationevent-outbound"></a>25.2&nbsp;Sending Spring ApplicationEvents</h2></div></div></div><p>
		To send Spring <code class="classname">ApplicationEvents</code>, create an instance of the
		<code class="classname">ApplicationEventPublishingMessageHandler</code> and register it within an endpoint.
		This implementation of the <code class="interfacename">MessageHandler</code> interface also implements
		Spring's <code class="interfacename">ApplicationEventPublisherAware</code> interface and thus acts as a
		bridge between Spring Integration Messages and <code class="classname">ApplicationEvents</code>.
	</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml"></a>26.&nbsp;Dealing with XML Payloads</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-intro"></a>26.1&nbsp;Introduction</h2></div></div></div><p>
			Spring Integration's XML support extends the Spring Integration Core with 
			implementations of splitter, transformer, selector and router designed 
			to make working with xml messages in Spring Integration simple.  The provided messaging 
			components are designed to work with xml represented in a range of formats including 
			instances of 
			<code class="classname">java.lang.String</code>, <code class="interfacename">org.w3c.dom.Document</code>  
			and <code class="interfacename">javax.xml.transform.Source</code>.  It should be noted however that 
			where a DOM representation is required, for example in order to evaluate an XPath expression, 
			the <code class="classname">String</code> payload will be converted into the required type and then 
			converted back again to <code class="classname">String</code>.  Components that require an instance of 
			<code class="interfacename">DocumentBuilder</code> will create a namespace aware instance if one is 
			not provided.  Where greater control of the document being created is required an appropriately 
			configured instance of <code class="interfacename">DocumentBuilder</code> should be provided. 
    	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-transformation"></a>26.2&nbsp;Transforming xml payloads</h2></div></div></div><p>
			This section will explain the workings of
			<code class="classname">XmlPayloadUnmarshallingTransformer</code>,
			<code class="classname">XmlPayloadMarshallingTransformer</code>,
			<code class="classname">XsltPayloadTransformer</code>
			and how to configure them as
			<span class="emphasis"><em>beans</em></span>.  All of the provided xml transformers extend 
			<code class="classname">AbstractPayloadTransformer</code> and therefore implement 
			<code class="interfacename">Transformer</code>.  When configuring xml transformers as beans in 
			Spring Integration you would normally configure the transformer in conjunction with either 
			a <code class="classname">MessageTransformingChannelInterceptor</code> or a 
			<code class="classname">MessageTransformingHandler</code>.  This allows the transformer to be used as either an interceptor,
			which transforms the message as it is sent or received to the channel, or as an endpoint.  Finally the 
			namespace support will be discussed which allows for the simple configuration of the transformers as 
			elements in XML.
		</p><p>
			<code class="classname">XmlPayloadUnmarshallingTransformer</code> allows an xml <code class="interfacename">Source</code> 
			to be unmarshalled using implementations of Spring OXM <code class="interfacename">Unmarshaller</code>.  
			Spring OXM provides several implementations supporting marshalling and unmarshalling using JAXB, 
			Castor and JiBX amongst others.  Since the unmarshaller requires an instance of 
			<code class="interfacename">Source</code> where the message payload is not currently an instance of
			<code class="interfacename">Source</code>, conversion will be attempted.  Currently <code class="classname">String</code>
			and <code class="interfacename">org.w3c.dom.Document</code> payloads are supported.  Custom conversion to a 
			<code class="interfacename">Source</code> is also supported by injecting an implementation of 
			<code class="interfacename">SourceFactory</code>.
			</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"unmarshallingTransformer"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.transformer.XmlPayloadUnmarshallingTransformer"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.oxm.jaxb.Jaxb1Marshaller"</span>&gt;
		    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"contextPath"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.example"</span> /&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
		</p><p>
			The <code class="classname">XmlPayloadMarshallingTransformer</code> allows an object graph to be converted 
			into xml using a Spring OXM <code class="interfacename">Marshaller</code>.  By default the 
			<code class="classname">XmlPayloadMarshallingTransformer</code> will return a <code class="classname">DomResult</code>.  
			However the type of result can be controlled by configuring an alternative <code class="interfacename">ResultFactory</code> 
			such as <code class="classname">StringResultFactory</code>.  In many cases it will be more convenient to transform 
			the payload into an alternative xml format.  To achieve this configure a 
			<code class="interfacename">ResultTransformer</code>.  Two implementations are provided, one which converts to 
			<code class="classname">String</code> and another which converts to <code class="interfacename">Document</code>.
			</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"marshallingTransformer"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.transformer.XmlPayloadMarshallingTransformer"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.oxm.jaxb.Jaxb1Marshaller"</span>&gt;
            &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"contextPath"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.example"</span> /&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.transformer.ResultToDocumentTransformer"</span> /&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>			
		</p><p>
			<code class="classname">XsltPayloadTransformer</code> transforms xml payloads using xsl.
			The transformer requires an instance of either <code class="interfacename">Resource</code> or
			<code class="interfacename">Templates</code>.  Passing in a <code class="interfacename">Templates</code> instance
			allows for greater configuration of the <code class="interfacename">TransformerFactory</code> used to create
			the template instance.  As in the case of <code class="classname">XmlPayloadMarshallingTransformer</code> 
			by default <code class="classname">XsltPayloadTransformer</code> will create a message with a 
			<code class="interfacename">Result</code> payload.  This can be customised by providing a 
			<code class="interfacename">ResultFactory</code> and/or a <code class="interfacename">ResultTransformer</code>.
			</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"xsltPayloadTransformer"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.transformer.XsltPayloadTransformer"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:org/example/xsl/transform.xsl"</span> /&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.transformer.ResultToDocumentTransformer"</span> /&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>			
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-transformer-namespace"></a>26.3&nbsp;Namespace support for xml transformers</h2></div></div></div><p>
			Namespace support for all xml transformers is provided in the Spring Integration xml namespace, 
			a template for which can be seen below.  The namespace support for transformers creates an instance of either 
			<code class="classname">EventDrivenConsumer</code> or <code class="classname">PollingConsumer</code> 
			according to the type of the provided input channel.  The namespace support is designed 
			to reduce the amount of xml configuration by allowing the creation of an endpoint and transformer 
			using one element.
			</p><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:integration</span>=<span class="hl-value">"http://www.springframework.org/schema/integration"</span>
       <span class="hl-attribute">xmlns:si-xml</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/xml"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/integration
           http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
           http://www.springframework.org/schema/integration/xml
           http://www.springframework.org/schema/integration/xml/spring-integration-xml-1.0.xsd"</span>&gt;
&lt;<span class="hl-tag">/beans</span>&gt;</pre><p>
		The namespace support for <code class="classname">XmlPayloadUnmarshallingTransformer</code> is shown below.
		Since the namespace is now creating an instance of <code class="interfacename">MessageEndpoint</code> rather 
		than a transformer a poller can also be nested within the element to control the polling of the input channel.  
		</p><pre class="programlisting">&lt;<span class="hl-tag">si-xml:unmarshalling-transformer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"defaultUnmarshaller"</span>
    <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">unmarshaller</span>=<span class="hl-value">"unmarshaller"</span>/&gt;

&lt;<span class="hl-tag">si-xml:unmarshalling-transformer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"unmarshallerWithPoller"</span>
    <span class="hl-attribute">input-channel</span>=<span class="hl-value">"input"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">unmarshaller</span>=<span class="hl-value">"unmarshaller"</span>&gt;
    &lt;<span class="hl-tag">si:poller</span>&gt;
        &lt;<span class="hl-tag">si:interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"2000"</span>/&gt;
    &lt;<span class="hl-tag">/si:poller</span>&gt;
&lt;<span class="hl-tag">si-xml:unmarshalling-transformer</span>/&gt;    
    </pre><p>
    </p><p>
    The namespace support for the marshalling transformer requires an input channel, output channel and a 
    reference to a marshaller.  The optional result-type attribute can be used to control the type of result created, 
    valid values are StringResult or DomResult (the default).  Where the provided result types are not sufficient a 
    reference to a custom implementation of <code class="interfacename">ResultFactory</code> can be provided as an alternative 
    to setting the result-type attribute using the result-factory attribute.  An optional result-transformer can also be 
    specified in order to convert the created <code class="interfacename">Result</code> after marshalling.  
		</p><pre class="programlisting">&lt;<span class="hl-tag">si-xml:marshalling-transformer</span>
     <span class="hl-attribute">input-channel</span>=<span class="hl-value">"marshallingTransformerStringResultFactory"</span>
     <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
     <span class="hl-attribute">marshaller</span>=<span class="hl-value">"marshaller"</span>
     <span class="hl-attribute">result-type</span>=<span class="hl-value">"StringResult"</span> /&gt;
     
&lt;<span class="hl-tag">si-xml:marshalling-transformer</span>
    <span class="hl-attribute">input-channel</span>=<span class="hl-value">"marshallingTransformerWithResultTransformer"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">marshaller</span>=<span class="hl-value">"marshaller"</span>
    <span class="hl-attribute">result-transformer</span>=<span class="hl-value">"resultTransformer"</span> /&gt;
     
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"resultTransformer"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.transformer.ResultToStringTransformer"</span>/&gt;</pre><p>
</p><p>
		Namespace support for the <code class="classname">XsltPayloadTransformer</code> allows either a resource to be passed in in order to create the 
		<code class="interfacename">Templates</code> instance or alternatively a precreated <code class="interfacename">Templates</code> 
		instance can be passed in as a reference.  In common with the marshalling transformer the type of the result output can 
		be controlled by specifying either the result-factory or result-type attribute.  A result-transfomer attribute can also 
		be used to reference an implementation of <code class="interfacename">ResultTransfomer</code> where conversion of the result 
		is required before sending.
	</p><pre class="programlisting">&lt;<span class="hl-tag">si-xml:xslt-transformer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"xsltTransformerWithResource"</span>
    <span class="hl-attribute">input-channel</span>=<span class="hl-value">"withResourceIn"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">xsl-resource</span>=<span class="hl-value">"org/springframework/integration/xml/config/test.xsl"</span>/&gt;
&lt;<span class="hl-tag">si-xml:xslt-transformer</span> <span class="hl-attribute">id</span>=<span class="hl-value">"xsltTransformerWithTemplatesAndResultTransformer"</span>
    <span class="hl-attribute">input-channel</span>=<span class="hl-value">"withTemplatesAndResultTransformerIn"</span>
    <span class="hl-attribute">output-channel</span>=<span class="hl-value">"output"</span>
    <span class="hl-attribute">xsl-templates</span>=<span class="hl-value">"templates"</span>
    <span class="hl-attribute">result-transformer</span>=<span class="hl-value">"resultTransformer"</span>/&gt;</pre><p>				
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xpath-splitting"></a>26.4&nbsp;Splitting xml messages</h2></div></div></div><p>
			<code class="classname">XPathMessageSplitter</code> supports messages with either 
			<code class="classname">String</code> or <code class="interfacename">Document</code> payloads. 
			The splitter uses the provided XPath expression to split the payload into a number of 
			nodes.  By default this will result in each <code class="interfacename">Node</code> instance
			becoming the payload of a new message.  Where it is preferred that each message be a Document
			the <code class="methodname">createDocuments</code> flag can be set.  Where a <code class="classname">String</code> payload is passed 
			in the payload will be converted then split before being converted back to a number of String 
			messages.  The XPath splitter implements <code class="interfacename">MessageHandler</code> and should 
			therefore be configured in conjunction with an appropriate endpoint (see the namespace support below
			for a simpler configuration alternative).
			</p><pre class="programlisting">&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"splittingEndpoint"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.endpoint.SubscribingConsumerEndpoint"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.splitter.XPathMessageSplitter"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/order/items"</span> /&gt;
            &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"documentBuilder"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customisedDocumentBuilder"</span> /&gt;
            &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"outputChannel"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"orderItemsChannel"</span> /&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"orderChannel"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>	     
				
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xpath-routing"></a>26.5&nbsp;Routing xml messages using XPath</h2></div></div></div><p>
			Two Router implementations based on XPath are provided <code class="classname">XPathSingleChannelRouter</code> and 
			<code class="classname">XPathMultiChannelRouter</code>.  The implementations differ in respect to how many channels 
			any given message may be routed to, exactly one in the case of the single channel version 
			or zero or more in the case of the multichannel router.  Both evaluate an XPath 
			expression against the xml payload of the message, supported payload types by default 
			are <code class="interfacename">Node</code>, <code class="interfacename">Document</code> and
			<code class="interfacename">String</code>.  For other payload types a custom implementation 
			of <code class="interfacename">XmlPayloadConverter</code> can be provided.  The router 
			implementations use <code class="interfacename">ChannelResolver</code> to convert the 
			result(s) of the XPath expression to a channel name.  By default a 
			<code class="classname">BeanFactoryChannelResolver</code> strategy will be used, this means that the string returned by the XPath 
			evaluation should correspond directly to the name of a channel.  Where this is not the case
			an alternative implementation of <code class="interfacename">ChannelResolver</code> can 
			be used.  Where there is a simple mapping from Xpath result to channel name
			the provided <code class="classname">MapBasedChannelResolver</code> can be used.
			</p><pre class="programlisting">&lt;<span class="hl-comment">!-- Expects a channel for each value of order type to exist  --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"singleChannelRoutingEndpoint"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.endpoint.SubscribingConsumerEndpoint"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.router.XPathSingleChannelRouter"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/order/@type"</span> /&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
	&lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"orderChannel"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
	
	
&lt;<span class="hl-comment">!-- Multi channel router which uses a map channel resolver to resolve the channel name
     based on the XPath evaluation result Since the router is multi channel it may deliver
     message to one or both of the configured channels --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"multiChannelRoutingEndpoint"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.endpoint.SubscribingConsumerEndpoint"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.router.XPathMultiChannelRouter"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/order/recipient"</span> /&gt;
            &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channelResolver"</span>&gt;
                &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.channel.MapBasedChannelResolver"</span>&gt;
                    &lt;<span class="hl-tag">constructor-arg</span>&gt;
                        &lt;<span class="hl-tag">map</span>&gt;
                            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"accounts"</span>
                                   <span class="hl-attribute">value-ref</span>=<span class="hl-value">"accountConfirmationChannel"</span> /&gt;
                            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"humanResources"</span>
                                   <span class="hl-attribute">value-ref</span>=<span class="hl-value">"humanResourcesConfirmationChannel"</span> /&gt;
                        &lt;<span class="hl-tag">/map</span>&gt;
                     &lt;<span class="hl-tag">/constructor-arg</span>&gt;
	             &lt;<span class="hl-tag">/bean</span>&gt;
            &lt;<span class="hl-tag">/property</span>&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"orderChannel"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>	
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xpath-selector"></a>26.6&nbsp;Selecting xml messages using XPath</h2></div></div></div><p>
			Two <code class="interfacename">MessageSelector</code> implementations are provided, 
			<code class="classname">BooleanTestXPathMessageSelector</code> and <code class="classname">StringValueTestXPathMessageSelector</code>.  
			<code class="classname">BooleanTestXPathMessageSelector</code> requires an XPathExpression which evaluates to a boolean, 
			for example <span class="emphasis"><em>boolean(/one/two)</em></span> which will only select messages which have an element named 
			two which is a child of a root element named one.  <code class="classname">StringValueTestXPathMessageSelector</code> 
			evaluates any XPath expression as a <code class="classname">String</code> and compares the result with the provided value. 
		</p><pre class="programlisting">&lt;<span class="hl-comment">!-- Interceptor which rejects messages that do not have a root element order  --</span>&gt;
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"orderSelectingInterceptor"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.channel.interceptor.MessageSelectingInterceptor"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.selector.BooleanTestXPathMessageSelector"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"boolean(/order)"</span> /&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
	
&lt;<span class="hl-comment">!--  Interceptor which rejects messages that are not version one orders --</span>&gt; 
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"versionOneOrderSelectingInterceptor"</span>
      <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.channel.interceptor.MessageSelectingInterceptor"</span>&gt;
    &lt;<span class="hl-tag">constructor-arg</span>&gt;
        &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.xml.selector.StringValueTestXPathMessageSelector"</span>&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/order/@version"</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span>/&gt;
            &lt;<span class="hl-tag">constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">index</span>=<span class="hl-value">"1"</span>/&gt;
        &lt;<span class="hl-tag">/bean</span>&gt;
    &lt;<span class="hl-tag">/constructor-arg</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xpath-namespace-support"></a>26.7&nbsp;XPath components namespace support</h2></div></div></div><p>All XPath based components have namespace support allowing them to be configured as
		Message Endpoints with the exception of the XPath selectors which are not designed to act as 
		endpoints.  Each component allows the XPath to either be referenced at the top level or configured via a nested 
		xpath-expression element.  So the following configurations of an xpath-selector are all valid and represent the general 
		form of XPath namespace support.  All forms of XPath expression result in the creation of an 
		<code class="interfacename">XPathExpression</code> using the Spring <code class="classname">XPathExpressionFactory</code>
		</p><pre class="programlisting">&lt;<span class="hl-tag">si-xml:xpath-selector</span> <span class="hl-attribute">id</span>=<span class="hl-value">"xpathRefSelector"</span>
                       <span class="hl-attribute">xpath-expression</span>=<span class="hl-value">"refToXpathExpression"</span>
                       <span class="hl-attribute">evaluation-result-type</span>=<span class="hl-value">"boolean"</span> /&gt;

&lt;<span class="hl-tag">si-xml:xpath-selector</span> <span class="hl-attribute">id</span>=<span class="hl-value">"selectorWithNoNS"</span> <span class="hl-attribute">evaluation-result-type</span>=<span class="hl-value">"boolean"</span> &gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/name"</span>/&gt;
&lt;<span class="hl-tag">/si-xml:xpath-selector</span>&gt;	
	
&lt;<span class="hl-tag">si-xml:xpath-selector</span> <span class="hl-attribute">id</span>=<span class="hl-value">"selectorWithOneNS"</span> <span class="hl-attribute">evaluation-result-type</span>=<span class="hl-value">"boolean"</span> &gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/ns1:name"</span>
                             <span class="hl-attribute">ns-prefix</span>=<span class="hl-value">"ns1"</span> <span class="hl-attribute">ns-uri</span>=<span class="hl-value">"www.example.org"</span> /&gt;
&lt;<span class="hl-tag">/si-xml:xpath-selector</span>&gt;
	
&lt;<span class="hl-tag">si-xml:xpath-selector</span> <span class="hl-attribute">id</span>=<span class="hl-value">"selectorWithTwoNS"</span> <span class="hl-attribute">evaluation-result-type</span>=<span class="hl-value">"boolean"</span> &gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/ns1:name/ns2:type"</span>&gt;
        &lt;<span class="hl-tag">map</span>&gt;
            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"ns1"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"www.example.org/one"</span> /&gt;
            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"ns2"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"www.example.org/two"</span> /&gt;
        &lt;<span class="hl-tag">/map</span>&gt;
    &lt;<span class="hl-tag">/si-xml:xpath-expression</span>&gt;
&lt;<span class="hl-tag">/si-xml:xpath-selector</span>&gt;
	
&lt;<span class="hl-tag">si-xml:xpath-selector</span> <span class="hl-attribute">id</span>=<span class="hl-value">"selectorWithNamespaceMapRef"</span> <span class="hl-attribute">evaluation-result-type</span>=<span class="hl-value">"boolean"</span> &gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/ns1:name/ns2:type"</span>
                             <span class="hl-attribute">namespace-map</span>=<span class="hl-value">"defaultNamespaces"</span>/&gt;
&lt;<span class="hl-tag">/si-xml:xpath-selector</span>&gt;
	
&lt;<span class="hl-tag">util:map</span> <span class="hl-attribute">id</span>=<span class="hl-value">"defaultNamespaces"</span>&gt;
    &lt;<span class="hl-tag">util:entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"ns1"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"www.example.org/one"</span> /&gt;
    &lt;<span class="hl-tag">util:entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"ns2"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"www.example.org/two"</span> /&gt;
&lt;<span class="hl-tag">/util:map</span>&gt;</pre><p>
		</p><p>
			XPath splitter namespace support allows the creation of a Message Endpoint with an input channel and output channel.
			</p><pre class="programlisting">&lt;<span class="hl-comment">!-- Split the order into items creating a new message for each item node --</span>&gt;
&lt;<span class="hl-tag">si-xml:xpath-splitter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"orderItemSplitter"</span>
                       <span class="hl-attribute">input-channel</span>=<span class="hl-value">"orderChannel"</span>
                       <span class="hl-attribute">output-channel</span>=<span class="hl-value">"orderItemsChannel"</span>&gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/order/items"</span>/&gt;
&lt;<span class="hl-tag">/si-xml:xpath-splitter</span>&gt;

&lt;<span class="hl-comment">!-- Split the order into items creating a new document for each item--</span>&gt;
&lt;<span class="hl-tag">si-xml:xpath-splitter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"orderItemDocumentSplitter"</span>
                       <span class="hl-attribute">input-channel</span>=<span class="hl-value">"orderChannel"</span> 
                       <span class="hl-attribute">output-channel</span>=<span class="hl-value">"orderItemsChannel"</span>
                       <span class="hl-attribute">create-documents</span>=<span class="hl-value">"true"</span>&gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/order/items"</span>/&gt;
    &lt;<span class="hl-tag">si:poller</span>&gt;
        &lt;<span class="hl-tag">si:interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"2000"</span>/&gt;
    &lt;<span class="hl-tag">/si:poller</span>&gt;
&lt;<span class="hl-tag">/si-xml:xpath-splitter</span>&gt;</pre><p>  
		</p><p>
			XPath router namespace support allows for the creation of a Message Endpoint with an input channel but no output channel 
			since the output channel is determined dynamically.  The multi-channel attribute causes the creation of a multi channel router capable of 
			routing a single message to many channels when true and a single channel router when false.
			</p><pre class="programlisting">&lt;<span class="hl-comment">!-- route the message according to exactly one order type channel --</span>&gt;
&lt;<span class="hl-tag">si-xml:xpath-router</span> <span class="hl-attribute">id</span>=<span class="hl-value">"orderTypeRouter"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"orderChannel"</span> <span class="hl-attribute">multi-channel</span>=<span class="hl-value">"false"</span>&gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/order/type"</span>/&gt;
&lt;<span class="hl-tag">/si-xml:xpath-router</span>&gt;

&lt;<span class="hl-comment">!-- route the order to all responders--</span>&gt;
&lt;<span class="hl-tag">si-xml:xpath-router</span> <span class="hl-attribute">id</span>=<span class="hl-value">"responderRouter"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"orderChannel"</span> <span class="hl-attribute">multi-channel</span>=<span class="hl-value">"true"</span>&gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/request/responders"</span>/&gt;
    &lt;<span class="hl-tag">si:poller</span>&gt;
        &lt;<span class="hl-tag">si:interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"2000"</span>/&gt;
    &lt;<span class="hl-tag">/si:poller</span>&gt;
&lt;<span class="hl-tag">/si-xml:xpath-router</span>&gt;</pre><p>
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="security"></a>27.&nbsp;Security in Spring Integration</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security-intro"></a>27.1&nbsp;Introduction</h2></div></div></div><p>
    	Spring Integration provides integration with the 
    	<a class="ulink" href="http://static.springframework.org/spring-security/site/" target="_top">Spring Security project</a> 
    	to allow role based security checks to be applied to channel send and receive invocations.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="securing-channels"></a>27.2&nbsp;Securing channels</h2></div></div></div><p>
    	Spring Integration provides the interceptor <code class="classname">ChannelSecurityInterceptor</code>, which extends 
    	<code class="classname">AbstractSecurityInterceptor</code> and intercepts send and receive calls on the channel.  Access decisions
    	are then made with reference to <code class="classname">ChannelInvocationDefinitionSource</code> which provides the definition of 
    	the send and receive security constraints.  The interceptor requires that a valid <code class="interfacename">SecurityContext</code>
    	has been established by authenticating with Spring Security, see the Spring Security reference documentation for details.     
	</p><p>
		Namespace support is provided to allow easy configuration of security constraints.  This consists of the secured channels tag which allows 
		definition of one or more channel name patterns in conjunction with a definition of the security configuration for send and receive.  The pattern
		is a <code class="interfacename">java.util.regexp.Pattern</code>.    
		</p><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">beans:beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/integration"</span>
 	<span class="hl-attribute">xmlns:si-security</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/security"</span>
	<span class="hl-attribute">xmlns:beans</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
	<span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="hl-attribute">xmlns:security</span>=<span class="hl-value">"http://www.springframework.org/schema/security"</span>
	<span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
			http://www.springframework.org/schema/security
			http://www.springframework.org/schema/security/spring-security-2.0.xsd
			http://www.springframework.org/schema/integration
			http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
			http://www.springframework.org/schema/integration/security
			http://www.springframework.org/schema/integration/security/spring-integration-security-1.0.xsd"</span>&gt;

&lt;<span class="hl-tag">si-security:secured-channels</span>&gt;
    &lt;<span class="hl-tag">si-security:access-policy</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"admin.*"</span> <span class="hl-attribute">send-access</span>=<span class="hl-value">"ROLE_ADMIN"</span>/&gt;
    &lt;<span class="hl-tag">si-security:access-policy</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"user.*"</span> <span class="hl-attribute">receive-access</span>=<span class="hl-value">"ROLE_USER"</span>/&gt;
&lt;<span class="hl-tag">/si-security:secured-channels</span>&gt;
	</pre><p>
	
	By default the secured-channels namespace element expects a bean named <span class="emphasis"><em>authenticationManager</em></span> which implements 
	<code class="interfacename">AuthenticationManager</code> and a bean named <span class="emphasis"><em>accessDecisionManager</em></span> which implements
	<code class="interfacename">AccessDecisionManager</code>.  Where this is not the case references to the appropriate beans can be configured 
	as attributes of the <span class="emphasis"><em>secured-channels</em></span> element as below.
	</p><pre class="programlisting">&lt;<span class="hl-tag">si-security:secured-channels</span> <span class="hl-attribute">access-decision-manager</span>=<span class="hl-value">"customAccessDecisionManager"</span>
                              <span class="hl-attribute">authentication-manager</span>=<span class="hl-value">"customAuthenticationManager"</span>&gt;
    &lt;<span class="hl-tag">si-security:access-policy</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"admin.*"</span> <span class="hl-attribute">send-access</span>=<span class="hl-value">"ROLE_ADMIN"</span>/&gt;
    &lt;<span class="hl-tag">si-security:access-policy</span> <span class="hl-attribute">pattern</span>=<span class="hl-value">"user.*"</span> <span class="hl-attribute">receive-access</span>=<span class="hl-value">"ROLE_USER"</span>/&gt;
&lt;<span class="hl-tag">/si-security:secured-channels</span>&gt;
	</pre><p>
	
    </p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="samples"></a>Appendix&nbsp;A.&nbsp;Spring Integration Samples</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
		Starting with the current release of Spring Integration the <span class="emphasis"><em>samples</em></span> are distributed as independent
		Maven-based projects (<a class="ulink" href="http://maven.apache.org/" target="_top">http://maven.apache.org/</a>) to minimize the setup time.
		Since each project is also an Eclipse-based project, they can be imported as is using the Eclipse Import wizard. 
		If you prefer another IDE, configuration should be very trivial, since a special Maven profile was setup to download all
		of the required dependencies for all samples. Detailed instructions on how to build and run the samples are provided in
		the <code class="code">README.txt</code> file located in the <span class="emphasis"><em>samples</em></span> directory of the main distribution.
	</td></tr></tbody></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples-cafe"></a>A.1&nbsp;The Cafe Sample</h2></div></div></div><p>
      In this section, we will review a sample application that is included in the Spring Integration
      distribution. This sample is inspired by one of the samples featured in Gregor Hohpe's
      <a class="ulink" href="http://www.eaipatterns.com/ramblings.html" target="_top">Ramblings</a>.
    </p><p>
      The domain is that of a Cafe, and the basic flow is depicted in the following diagram:
    </p><p>
      </p><div class="mediaobject" align="center"><img src="./Spring Integration Reference Manual_files/cafe-demo.png" align="middle"></div><p>
    </p><p>
      The <code class="classname">Order</code> object may contain multiple <code class="classname">OrderItems</code>. Once the order
      is placed, a <span class="emphasis"><em>Splitter</em></span> will break the composite order message into a single message per
      drink. Each of these is then processed by a <span class="emphasis"><em>Router</em></span> that determines whether the drink is hot
      or cold (checking the <code class="classname">OrderItem</code> object's 'isIced' property). The
      <code class="classname">Barista</code> prepares each drink, but hot and cold drink preparation are handled by two
      distinct methods: 'prepareHotDrink' and 'prepareColdDrink'. The prepared drinks are then sent to the Waiter where
      they are aggregated into a <code class="classname">Delivery</code> object.
    </p><p>
      Here is the XML configuration:
      </p><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">beans:beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/integration"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:beans</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:stream</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/stream"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/integration
            http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
            http://www.springframework.org/schema/integration/stream
            http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd"</span>&gt;

    &lt;<span class="hl-tag">gateway</span> <span class="hl-attribute">id</span>=<span class="hl-value">"cafe"</span> <span class="hl-attribute">service-interface</span>=<span class="hl-value">"org.springframework.integration.samples.cafe.Cafe"</span>/&gt;

    &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"orders"</span>/&gt;
    &lt;<span class="hl-tag">splitter</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"orders"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"orderSplitter"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"split"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"drinks"</span>/&gt;

    &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"drinks"</span>/&gt;
    &lt;<span class="hl-tag">router</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"drinks"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"drinkRouter"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"resolveOrderItemChannel"</span>/&gt;

    &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"coldDrinks"</span>&gt;
        &lt;<span class="hl-tag">queue</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"10"</span>/&gt;
    &lt;<span class="hl-tag">/channel</span>&gt;
    &lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"coldDrinks"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"barista"</span>
                       <span class="hl-attribute">method</span>=<span class="hl-value">"prepareColdDrink"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"preparedDrinks"</span>/&gt;

    &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"hotDrinks"</span>&gt;
        &lt;<span class="hl-tag">queue</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"10"</span>/&gt;
    &lt;<span class="hl-tag">/channel</span>&gt;
    &lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"hotDrinks"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"barista"</span>
                       <span class="hl-attribute">method</span>=<span class="hl-value">"prepareHotDrink"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"preparedDrinks"</span>/&gt;

    &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"preparedDrinks"</span>/&gt;
    &lt;<span class="hl-tag">aggregator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"preparedDrinks"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"waiter"</span>
                <span class="hl-attribute">method</span>=<span class="hl-value">"prepareDelivery"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"deliveries"</span>/&gt;

    &lt;<span class="hl-tag">stream:stdout-channel-adapter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"deliveries"</span>/&gt;

    &lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"orderSplitter"</span>
                <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.samples.cafe.xml.OrderSplitter"</span>/&gt;

    &lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"drinkRouter"</span>
                <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.samples.cafe.xml.DrinkRouter"</span>/&gt;

    &lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"barista"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.samples.cafe.xml.Barista"</span>/&gt;

    &lt;<span class="hl-tag">beans:bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"waiter"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.samples.cafe.xml.Waiter"</span>/&gt;

    &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">id</span>=<span class="hl-value">"poller"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"true"</span>&gt;
        &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"1000"</span>/&gt;
    &lt;<span class="hl-tag">/poller</span>&gt;

&lt;<span class="hl-tag">/beans:beans</span>&gt;</pre><p>
      As you can see, each Message Endpoint is connected to input and/or output channels. Each endpoint will manage
      its own Lifecycle (by default endpoints start automatically upon initialization - to prevent that add the
      "auto-startup" attribute with a value of "false"). Most importantly, notice that the objects are simple POJOs
      with strongly typed method arguments. For example, here is the Splitter:
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OrderSplitter {

    <span class="hl-keyword">public</span> List&lt;OrderItem&gt; split(Order order) {
        <span class="hl-keyword">return</span> order.getItems();
    }
}</pre><p>
    In the case of the Router, the return value does not have to be a <code class="interfacename">MessageChannel</code>
    instance (although it can be). As you see in this example, a String-value representing the channel name is
    returned instead.
    </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DrinkRouter {

    <span class="hl-keyword">public</span> String resolveOrderItemChannel(OrderItem orderItem) {
        <span class="hl-keyword">return</span> (orderItem.isIced()) ? <span class="hl-string">"coldDrinks"</span> : <span class="hl-string">"hotDrinks"</span>;
    }
}</pre><p>
    </p><p>
      Now turning back to the XML, you see that there are two &lt;service-activator&gt; elements. Each of these
      is delegating to the same <code class="classname">Barista</code> instance but different methods: 'prepareHotDrink'
      or 'prepareColdDrink' corresponding to the two channels where order items have been routed.
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Barista {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> hotDrinkDelay = 5000;
    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> coldDrinkDelay = 1000;

    <span class="hl-keyword">private</span> AtomicInteger hotDrinkCounter = <span class="hl-keyword">new</span> AtomicInteger();
    <span class="hl-keyword">private</span> AtomicInteger coldDrinkCounter = <span class="hl-keyword">new</span> AtomicInteger();

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setHotDrinkDelay(<span class="hl-keyword">long</span> hotDrinkDelay) {
        <span class="hl-keyword">this</span>.hotDrinkDelay = hotDrinkDelay;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setColdDrinkDelay(<span class="hl-keyword">long</span> coldDrinkDelay) {
        <span class="hl-keyword">this</span>.coldDrinkDelay = coldDrinkDelay;
    }

    <span class="hl-keyword">public</span> Drink prepareHotDrink(OrderItem orderItem) {
        <span class="hl-keyword">try</span> {
            Thread.sleep(<span class="hl-keyword">this</span>.hotDrinkDelay);
            System.out.println(Thread.currentThread().getName()
                    + <span class="hl-string">" prepared hot drink #"</span> + hotDrinkCounter.incrementAndGet()
                    + <span class="hl-string">" for order #"</span> + orderItem.getOrder().getNumber() + <span class="hl-string">": "</span> + orderItem);
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Drink(orderItem.getOrder().getNumber(), orderItem.getDrinkType(),
                    orderItem.isIced(), orderItem.getShots());
        }
        <span class="hl-keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
            <span class="hl-keyword">return</span> null;
        }
    }

    <span class="hl-keyword">public</span> Drink prepareColdDrink(OrderItem orderItem) {
        <span class="hl-keyword">try</span> {
            Thread.sleep(<span class="hl-keyword">this</span>.coldDrinkDelay);
            System.out.println(Thread.currentThread().getName()
                    + <span class="hl-string">" prepared cold drink #"</span> + coldDrinkCounter.incrementAndGet()
                    + <span class="hl-string">" for order #"</span> + orderItem.getOrder().getNumber() + <span class="hl-string">": "</span> + orderItem);
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Drink(orderItem.getOrder().getNumber(), orderItem.getDrinkType(),
                    orderItem.isIced(), orderItem.getShots());
        }
        <span class="hl-keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
            <span class="hl-keyword">return</span> null;
        }
    }

}</pre><p>
    </p><p>
      As you can see from the code excerpt above, the barista methods have different delays (the hot drinks take 5
      times as long to prepare). This simulates work being completed at different rates. When the
      <code class="classname">CafeDemo</code> 'main' method runs, it will loop 100 times sending a single hot drink and a
      single cold drink each time. It actually sends the messages by invoking the 'placeOrder' method on the Cafe
      interface. Above, you will see that the &lt;gateway&gt; element is specified in the configuration file. This
      triggers the creation of a proxy that implements the given 'service-interface' and connects it to a channel.
      The channel name is provided on the @Gateway annotation of the <code class="interfacename">Cafe</code> interface.
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Cafe {

    @Gateway(requestChannel=<span class="hl-string">"orders"</span>)
    <span class="hl-keyword">void</span> placeOrder(Order order);

}</pre><p>
      Finally, have a look at the <code class="methodname">main()</code> method of the <code class="classname">CafeDemo</code> itself.
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
    AbstractApplicationContext context = null;
    <span class="hl-keyword">if</span> (args.length &gt; 0) {
        context = <span class="hl-keyword">new</span> FileSystemXmlApplicationContext(args);
    }
    <span class="hl-keyword">else</span> {
        context = <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">"cafeDemo.xml"</span>, CafeDemo.<span class="hl-keyword">class</span>);
    }
    Cafe cafe = (Cafe) context.getBean(<span class="hl-string">"cafe"</span>);
    <span class="hl-keyword">for</span> (<span class="hl-keyword">int</span> i = 1; i &lt;= 100; i++) {
        Order order = <span class="hl-keyword">new</span> Order(i);
        order.addItem(DrinkType.LATTE, 2, false);
        order.addItem(DrinkType.MOCHA, 3, true);
        cafe.placeOrder(order);
    }
}</pre><p>
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
      To run this sample as well as 8 others, refer to the <code class="code">README.txt</code> within the "samples" directory
      of the main distribution as described at the beginning of this chapter.
    </td></tr></tbody></table></div><p>
      When you run cafeDemo, you will see that the cold drinks are initially prepared more quickly than the hot drinks.
      Because there is an aggregator, the cold drinks are effectively limited by the rate of the hot drink preparation.
      This is to be expected based on their respective delays of 1000 and 5000 milliseconds. However, by configuring a
      poller with a concurrent task executor, you can dramatically change the results. For example, you could use a
      thread pool executor with 5 workers for the hot drink barista while keeping the cold drink barista as it is:
      </p><pre class="programlisting">&lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"hotDrinks"</span>
                   <span class="hl-attribute">ref</span>=<span class="hl-value">"barista"</span>
                   <span class="hl-attribute">method</span>=<span class="hl-value">"prepareHotDrink"</span>
                   <span class="hl-attribute">output-channel</span>=<span class="hl-value">"preparedDrinks"</span>/&gt;

&lt;<span class="hl-tag">service-activator</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"hotDrinks"</span>
                   <span class="hl-attribute">ref</span>=<span class="hl-value">"barista"</span>
                   <span class="hl-attribute">method</span>=<span class="hl-value">"prepareHotDrink"</span>
                   <span class="hl-attribute">output-channel</span>=<span class="hl-value">"preparedDrinks"</span>&gt;
    &lt;<span class="hl-tag">poller</span> <span class="hl-attribute">task-executor</span>=<span class="hl-value">"pool"</span>&gt;
        &lt;<span class="hl-tag">interval-trigger</span> <span class="hl-attribute">interval</span>=<span class="hl-value">"1000"</span>/&gt;
    &lt;<span class="hl-tag">/poller</span>&gt;
&lt;<span class="hl-tag">/service-activator</span>&gt;

&lt;<span class="hl-tag">thread-pool-task-executor</span> <span class="hl-attribute">id</span>=<span class="hl-value">"pool"</span> <span class="hl-attribute">core-size</span>=<span class="hl-value">"5"</span>/&gt;</pre><p>
    </p><p>
      Also, notice that the worker thread name is displayed with each invocation. You will see that the hot drinks are
      prepared by the task-executor threads. If you provide a much shorter poller interval (such as 100 milliseconds),
      then you will notice that occasionally it throttles the input by forcing the task-scheduler (the caller) to invoke
      the operation.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      In addition to experimenting with the poller's concurrency settings, you can also add the 'transactional'
      sub-element and then refer to any PlatformTransactionManager instance within the context.
    </td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples-xml-messaging"></a>A.2&nbsp;The XML Messaging Sample</h2></div></div></div><p>
    	The xml messaging sample in the <span class="package">org.springframework.integration.samples.xml</span> illustrates how to use 
    	some of the provided components which deal with xml payloads.  The sample uses the idea of processing an order for books
    	represented as xml.   
    </p><p>
    First the order is split into a number of messages, each one representing a single order item using
    	the XPath splitter component.
    	  </p><pre class="programlisting">&lt;<span class="hl-tag">si-xml:xpath-splitter</span> <span class="hl-attribute">id</span>=<span class="hl-value">"orderItemSplitter"</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"ordersChannel"</span> 
            <span class="hl-attribute">output-channel</span>=<span class="hl-value">"stockCheckerChannel"</span> <span class="hl-attribute">create-documents</span>=<span class="hl-value">"true"</span>&gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/orderNs:order/orderNs:orderItem"</span> <span class="hl-attribute">namespace-map</span>=<span class="hl-value">"orderNamespaceMap"</span> /&gt;
&lt;<span class="hl-tag">/si-xml:xpath-splitter</span>&gt;
</pre><p>
    </p><p>
    	A service activator is then used to pass the message into a stock checker POJO.  The order item document is enriched with information 
    	from the stock checker about order item stock level.  This enriched order item message is then used to route the message.  In the 
    	case where the order item is in stock the message is routed to the warehouse.  The XPath router makes use of a 
    	<code class="classname">MapBasedChannelResolver</code> which maps the XPath evaluation result to a channel reference.
    	</p><pre class="programlisting">&lt;<span class="hl-tag">si-xml:xpath-router</span> <span class="hl-attribute">id</span>=<span class="hl-value">"instockRouter"</span> <span class="hl-attribute">channel-resolver</span>=<span class="hl-value">"mapChannelResolver"</span> 
        <span class="hl-attribute">input-channel</span>=<span class="hl-value">"orderRoutingChannel"</span> <span class="hl-attribute">resolution-required</span>=<span class="hl-value">"true"</span>&gt;
    &lt;<span class="hl-tag">si-xml:xpath-expression</span> <span class="hl-attribute">expression</span>=<span class="hl-value">"/orderNs:orderItem/@in-stock"</span> <span class="hl-attribute">namespace-map</span>=<span class="hl-value">"orderNamespaceMap"</span>  /&gt;
&lt;<span class="hl-tag">/si-xml:xpath-router</span>&gt;
	
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"mapChannelResolver"</span>
    <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.integration.channel.MapBasedChannelResolver"</span>&gt;
    &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"channelMap"</span>&gt;
        &lt;<span class="hl-tag">map</span>&gt;
            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"warehouseDispatchChannel"</span> /&gt;
            &lt;<span class="hl-tag">entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">"false"</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">"outOfStockChannel"</span> /&gt;
        &lt;<span class="hl-tag">/map</span>&gt;
    &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;
</pre><p>    	 
    </p><p>
    	Where the order item is not in stock the message is transformed using 
    	xslt into a format suitable for sending to the supplier.
    		</p><pre class="programlisting">&lt;<span class="hl-tag">si-xml:xslt-transformer</span> <span class="hl-attribute">input-channel</span>=<span class="hl-value">"outOfStockChannel"</span> <span class="hl-attribute">output-channel</span>=<span class="hl-value">"resupplyOrderChannel"</span> 
     <span class="hl-attribute">xsl-resource</span>=<span class="hl-value">"classpath:org/springframework/integration/samples/xml/bigBooksSupplierTransformer.xsl"</span>/&gt;
</pre><p>    	 
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="samples-osgi"></a>A.3&nbsp;The OSGi Samples</h2></div></div></div><p>
		This release of Spring Integration includes several samples that are OSGi enabled as well as samples that were
		specifically designed to show some of the other benefits of OSGi and Spring Integration when used together.
		First lets look at the two familiar examples that are also configured to be valid OSGi bundles. These are
		<span class="emphasis"><em>Hello World</em></span> and <span class="emphasis"><em>Cafe</em></span>. All you need to do to see these samples work in
		an OSGi environment is deploy the generated JAR into such an environment.
	</p><p>
		Use Maven to generate the JAR by executing the 'mvn install' command on either of these projects. This will
		generate the JAR file in the target directory. Now you can simply drop that JAR file into the deployment
		directory of your OSGi platform. For example, if you are using
		<a class="ulink" href="http://www.springsource.com/products/dmserver" target="_top">SpringSource dm Server</a>,
		drop the files into the 'pickup' directory within the dm Server home directory.
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
		Prior to deploying and testing Spring Integration samples in the dm Server or any other OSGi server platform,
		you must have the Spring Integration and Spring bundles installed on that platform. For example, to install
		Spring Integration into SpringSource dm Server, copy all JAR files that are located in the 'dist' directory of
		your Spring Integration distribution into the 'repository/bundles/usr' directory of your dm Server instance
		(see the
		<a class="ulink" href="http://static.springsource.com/projects/dm-server/1.0.x/user-guide/htmlsingle/user-guide.html" target="_top">dm Server User Guide</a>
		for more detail on how to install bundles).
	</td></tr></tbody></table></div><p>
		The Spring Integration samples require a few other bundles to be installed. For the 1.0.3 release, the full
		list including transitive dependencies is:
		</p><div class="itemizedlist"><ul type="disc"><li>org.apache.commons.codec-1.3.0.jar</li><li>org.apache.commons.collections-3.2.0.jar</li><li>org.apache.commons.httpclient-3.1.0.jar</li><li>org.apache.ws.commons.schema-1.3.2.jar</li><li>org.springframework.oxm-1.5.5.A.jar</li><li>org.springframework.security-2.0.4.A.jar</li><li>org.springframework.ws-1.5.5.A.jar</li><li>org.springframework.xml-1.5.5.A.jar</li></ul></div><p>
		These are all located within the 'lib' directory of the Spring Integration distribution. So, you can simply
		copy those JARs into the dm Server 'repository/bundles/usr' directory as well.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			The Spring Framework bundles (aop, beans, context, etc.) are also included in the 'lib' directory of the
			Spring Integration distribution, but they do not need to be installed since they are already part of the
			dm Server infrastructure. Also, note that the versions listed above are those included with the Spring
			Integration 1.0.3 release. Newer versions of individual JARs may be used as long as they are within the
			range specified in the MANIFEST.MF files of those bundles that depend upon them.
		</td></tr></tbody></table></div><p>
		</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
			The bundles listed above are appropriate for a SpringSource dm Server 1.0.x deployment environment
			with a Spring Framework 2.5.x foundation. That is the version against which Spring Integration 1.0.3
			has been developed and tested. However, as of the time of the Spring Integration 1.0.3 release, the
			Spring Framework 3.0 release candidates are about to be available, and the dm Server 2.0.x milestones
			are available. If you want to try running these samples in that environment, then you will need to
			replace the Spring Security and Spring Web Services bundles with versions that support Spring 3.0.
			The OXM functionality is moving into the Spring Framework itself for the 3.0 release. Otherwise,
			Spring Integration 1.0.3 has been superficially tested against the Spring 3.0 snapshots available
			at the time of its release. In fact, some internal changes were made in the 1.0.3 release
			specifically to support Spring 3.0 (whereas 1.0.2 does not). Spring Integration 2.0 will be built
			upon a Spring 3.0 foundation.
		</td></tr></tbody></table></div><p>
	</p><p>
		To demonstrate some of the benefits of running Spring Integration projects in an OSGi environment (e.g.
		modularity, OSGi service dynamics, etc.), we have included a couple new samples that are dedicated to
		highlighting those benefits. In the 'samples' directory, you will find the following two projects:
		</p><div class="itemizedlist"><ul type="disc"><li>osgi-inbound (producer bundle)</li><li>osgi-outbound (consumer bundle)</li></ul></div><p>
		Unlike the other samples in the distribution, these are not Maven enabled. Instead, we have simply configured
		them as valid dm Server Bundle projects. That means you can import these projects directly into an STS
		workspace using the "Existing Projects into Workspace" option from the Eclipse Import wizard. Then, you can
		take advantage of the STS dm Server tools to deploy them into a SpringSource dm Server instance.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			A simple Ant 'build.xml' file has been included within each of these projects as well. The build
			files contain a single 'jar' target. Therefore, after these projects have been built within
			Eclipse/STS, you can generate the bundle (JAR) directly and deploy it manually.
		</td></tr></tbody></table></div><p>
	</p><p>
		The structure of these projects is very simple, yet the concepts they showcase are quite powerful. The
		'osgi-inbound' module enables sending a Message to a Publish-Subscribe Channel using a Spring Integration
		Gateway proxy. The interesting part, however, is that the Publish-Subscribe Channel is exported as an OSGi
		service via the &lt;osgi:service/&gt; element. As a result, any other bundles can be developed, deployed, and
		maintained independently yet still subscribe to that channel.
	</p><p>
		The 'osgi-outbound' module is an example of such a subscribing consumer bundle. It uses the corresponding
		&lt;osgi:reference/&gt; element to locate the channel exported by the 'osgi-inbound' bundle. It also contains
		configuration for a &lt;file:outbound-gateway/&gt; which is a subscriber to that channel and will write the
		Message content to a file once it arrives. It then sends a response Message with the name of the file and its
		location.
	</p><p>
		To make it easy to run, we've exposed a command-line interface where you can type in the command, the message,
		and the file name to execute the demo. This is exposed through the OSGi console. Likewise, the response that
		provides the name and location of the resulting file will also be visible within the OSGi console.
	</p><p>
		To run these samples, make sure your OSGi environment is properly configured to host Spring Integration bundles
		(as described in the note above). Deploy the producer bundle (osgi-inbound) first, and then deploy the consumer
		bundle (osgi-outbound). After you have deployed these bundles, open the OSGi console and type the following
		command:
		</p><pre class="programlisting"> osgi&gt; help </pre><p>
		You will see the following amidst the output:
		</p><pre class="programlisting"> ---Spring Integration CLI-based OSGi Demo---
         siSend &lt;message&gt; &lt;filename&gt; - send text to be written to a file</pre><p>
		As you can see, that describes the command that you will be able to use to send messages. If you are interested
		in how it is implemented or want to customize message sending logic or even create a new command look at
		<code class="classname">InboundDemoBundleActivator.java</code> in the consumer bundle.
		</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
			By default, when using dm Server, you can open the OSGi console by connecting to port 2401 via telnet:
			<pre class="programlisting"> telnet localhost 2401</pre></td></tr></tbody></table></div><p>
	</p><p>
		Now send a message by typing: </p><pre class="programlisting"> osgi&gt; siSend "Hello World" hello.txt</pre><p>
		You will see something similar to the following in the OSGi console:
		</p><pre class="programlisting"> Sending message: 'Hello World'
 Message sent and its contents were written to:   
 /usr/local/dm-server/work/tmp/spring-integration-samples/output/hello.txt</pre><p>
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			It is not necessary to wrap the message in quotes if it does not contain spaces.
			Go ahead and open up the file and verify that the message content was written to it.
		</td></tr></tbody></table></div><p>
	</p><p>
		Let's assume you wanted to change the directory to which the files are written or make any other change to the
		consumer bundle (osgi-outboud). You only need to update the consumer bundle and not the producer bundle. So, go
		ahead and change the directory in the 'osgi-outbound.xml' file located within 'src/META-INF/spring' and refresh
		the consumer bundle.
		</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
			If using STS to deploy to dm Server, the refresh will happen automatically. If replacing bundles manually,
			you can issue the command 'refresh n' in the OSGi console (where n would be the ID of the bundle as
			displayed at any point after issuing the 'ss' command to see the short status output).
		</td></tr></tbody></table></div><p>
		You will see that the change takes affect immediately. Not only that, you could even start developing and
		deploying new bundles that subscribe to the messages produced by the producer bundle the same way as the existing
		consumer bundle (osgi-outbound) does. With a publish-subscribe-channel any newly deployed bundles would start
		receiving each Message as well.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			If you also want to modify and refresh the producer bundle, be sure to refresh the consumer bundle
			afterwards as well. This is necessary because the consumer's subscription must be explicitly re-enabled
			after the producer's channel disappears. You could alternatively deploy a relatively static bundle that
			defines channels so that producers and consumers can be completely dynamic without affecting each other
			at all. In Spring Integration 2.0, we plan to support automatic re-subscription and more through the use
			of a <span class="emphasis"><em>Control Bus</em></span>.
		</td></tr></tbody></table></div><p>
	</p><p>
		That pretty much wraps up this very simple example. Hopefully it has successfully demonstrated the benefits of
		modularity and OSGi service dynamics while working with Spring Integration. Feel free to experiment by following
		some of the suggestions mentioned above. For deeper coverage of the applicability of OSGi when used with Spring
		Integration, read <a class="ulink" href="http://blog.springsource.com/2009/02/27/spring-integration-on-dm-server/" target="_top">this blog</a>
		by Spring Integration team member Iwein Fuld.
	</p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Appendix&nbsp;B.&nbsp;Configuration</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-introduction"></a>B.1&nbsp;Introduction</h2></div></div></div><p>
      Spring Integration offers a number of configuration options. Which option you choose depends upon your particular
      needs and at what level you prefer to work. As with the Spring framework in general, it is also possible to mix
      and match the various techniques according to the particular problem at hand. For example, you may choose the
      XSD-based namespace for the majority of configuration combined with a handful of objects that are configured with
      annotations. As much as possible, the two provide consistent naming. XML elements defined by the XSD schema will
      match the names of annotations, and the attributes of those XML elements will match the names of annotation
      properties. Direct usage of the API is of course always an option, but we expect that most users will choose one
      of the higher-level options, or a combination of the namespace-based and annotation-driven configuration.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namespace"></a>B.2&nbsp;Namespace Support</h2></div></div></div><p>
      Spring Integration components can be configured with XML elements that map directly to the terminology and
      concepts of enterprise integration. In many cases, the element names match those of the
      <a class="ulink" href="http://www.eaipatterns.com/" target="_top">Enterprise Integration Patterns</a>.
    </p><p>
      To enable Spring Integration's core namespace support within your Spring configuration files, add the following
      namespace reference and schema mapping in your top-level 'beans' element:
      </p><pre class="programlisting">&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:integration</span>=<span class="hl-value">"http://www.springframework.org/schema/integration"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/integration
           http://www.springframework.org/schema/integration/spring-integration-1.0.xsd"</span>&gt;</pre><p>
    </p><p>
	  You can choose any name after "xmlns:"; <span class="emphasis"><em>integration</em></span> is used here for clarity, but you might
      prefer a shorter abbreviation. Of course if you are using an XML-editor or IDE support, then the availability of
      auto-completion may convince you to keep the longer name for clarity. Alternatively, you can create configuration
      files that use the Spring Integration schema as the primary namespace:
      </p><pre class="programlisting">&lt;<span class="hl-tag">beans:beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/integration"</span>
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="hl-attribute">xmlns:beans</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/integration
           http://www.springframework.org/schema/integration/spring-integration-1.0.xsd"</span>&gt;</pre><p>
    </p><p>
      When using this alternative, no prefix is necessary for the Spring Integration elements. On the other hand, if
      you want to define a generic Spring "bean" within the same configuration file, then a prefix would be required
      for the bean element (&lt;beans:bean ... /&gt;). Since it is generally a good idea to modularize the
      configuration files themselves based on responsibility and/or architectural layer, you may find it appropriate to
      use the latter approach in the integration-focused configuration files, since generic beans are seldom necessary
      within those same files. For purposes of this documentation, we will assume the "integration" namespace is
      primary.
    </p><p>
      Many other namespaces are provided within the Spring Integration distribution. In fact, each adapter type (JMS,
      File, etc.) that provides namespace support defines its elements within a separate schema. In order to use these
      elements, simply add the necessary namespaces with an "xmlns" entry and the corresponding "schemaLocation" mapping.
      For example, the following root element shows several of these namespace declarations:
      </p><pre class="programlisting">&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:integration</span>=<span class="hl-value">"http://www.springframework.org/schema/integration"</span>
    <span class="hl-attribute">xmlns:file</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/file"</span>
    <span class="hl-attribute">xmlns:jms</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/jms"</span>
    <span class="hl-attribute">xmlns:mail</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/mail"</span>
    <span class="hl-attribute">xmlns:rmi</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/rmi"</span>
    <span class="hl-attribute">xmlns:ws</span>=<span class="hl-value">"http://www.springframework.org/schema/integration/ws"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/integration
            http://www.springframework.org/schema/integration/spring-integration-1.0.xsd
            http://www.springframework.org/schema/integration/file
            http://www.springframework.org/schema/integration/file/spring-integration-file-1.0.xsd
            http://www.springframework.org/schema/integration/jms
            http://www.springframework.org/schema/integration/jms/spring-integration-jms-1.0.xsd
            http://www.springframework.org/schema/integration/mail
            http://www.springframework.org/schema/integration/mail/spring-integration-mail-1.0.xsd
            http://www.springframework.org/schema/integration/rmi
            http://www.springframework.org/schema/integration/rmi/spring-integration-rmi-1.0.xsd
            http://www.springframework.org/schema/integration/ws
            http://www.springframework.org/schema/integration/ws/spring-integration-ws-1.0.xsd"</span>&gt;
 ...
&lt;<span class="hl-tag">/beans</span>&gt;</pre><p>
      The reference manual provides specific examples of the various elements in their corresponding chapters. Here, the
      main thing to recognize is the consistency of the naming for each namespace URI and schema location.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="namespace-taskscheduler"></a>B.3&nbsp;Configuring the Task Scheduler</h2></div></div></div><p>
      In Spring Integration, the ApplicationContext plays the central role of a Message Bus, and there are only a
      couple configuration options to be aware of. First, you may want to control the central TaskScheduler instance.
      You can do so by providing a single bean with the name "taskScheduler". This is also defined as a constant:
      </p><pre class="programlisting"> IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME </pre><p>
      By default Spring Integration uses the <code class="classname">SimpleTaskScheduler</code> implementation. That in turn
      just delegates to any instance of Spring's <code class="interfacename">TaskExecutor</code> abstraction. Therefore,
      it's rather trivial to supply your own configuration. The "taskScheduler" bean is then responsible for managing
      all pollers. The TaskScheduler will startup automatically by default. If you provide your own instance of
      SimpleTaskScheduler however, you can set the 'autoStartup' property to <span class="emphasis"><em>false</em></span> instead.
    </p><p>
      When Polling Consumers provide an explicit task-executor reference in their configuration, the invocation of
      the handler methods will happen within that executor's thread pool and not the main scheduler pool. However,
      when no task-executor is provided for an endpoint's poller, it will be invoked by one of the main scheduler's
      threads.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
         An endpoint is a <span class="emphasis"><em>Polling Consumer</em></span> if its input channel is one of the queue-based
         (i.e. pollable) channels. On the other hand, <span class="emphasis"><em>Event Driven Consumers</em></span> are those whose
         input channels have dispatchers instead of queues (i.e. they are subscribable). Such endpoints have no
         poller configuration since their handlers will be invoked directly.
      </td></tr></tbody></table></div><p>
      </p><p>
        The next section will describe what happens if Exceptions occur within the asynchronous invocations.
      </p><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="namespace-errorhandler"></a>B.4&nbsp;Error Handling</h2></div></div></div><p>
      As described in the overview at the very beginning of this manual, one of the main motivations behind a
      Message-oriented framework like Spring Integration is to promote loose-coupling between components. The
      Message Channel plays an important role in that producers and consumers do not have to know about each
      other. However, the advantages also have some drawbacks. Some things become more complicated in a very
      loosely coupled environment, and one example is error handling.
    </p><p>
      When sending a Message to a channel, the component that ultimately handles that Message may or may not
      be operating within the same thread as the sender. If using a simple default DirectChannel (with the
      &lt;channel&gt; element that has no &lt;queue&gt; sub-element and no 'task-executor' attribute), the
      Message-handling will occur in the same thread as the Message-sending. In that case, if an Exception
      is thrown, it can be caught by the sender (or it may propagate past the sender if it is an uncaught
      RuntimeException). So far, everything is fine. This is the same behavior as an Exception-throwing
      operation in a normal call stack. However, when adding the asynchronous aspect, things become much
      more complicated. For instance, if the 'channel' element <span class="emphasis"><em>does</em></span> provide a 'queue'
      sub-element, then the component that handles the Message <span class="emphasis"><em>will</em></span> be operating in a
      different thread than the sender. The sender may have dropped the Message into the channel and moved
      on to other things. There is no way for the Exception to be thrown directly back to that sender using
      standard Exception throwing techniques. Instead, to handle errors for asynchronous processes requires
      an asynchronous error-handling mechanism as well.
    </p><p>
      Spring Integration supports error handling for its components by publishing errors to a Message Channel.
      Specifically, the Exception will become the payload of a Spring Integration Message. That Message will
      then be sent to a Message Channel that is resolved in a way that is similar to the 'replyChannel'
      resolution. First, if the request Message being handled at the time the Exception occurred contains
      an 'errorChannel' header (the header name is defined in the constant: MessageHeaders.ERROR_CHANNEL),
      the ErrorMessage will be sent to that channel. Otherwise, the error handler will send to a "global"
      channel whose bean name is "errorChannel" (this is also defined as a constant:
      IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME).
    </p><p>
      Whenever relying on Spring Integration's XML namespace support, a default "errorChannel" bean will be
      created behind the scenes. However, you can just as easily define your own if you want to control the
      settings.
      </p><pre class="programlisting"> &lt;<span class="hl-tag">channel</span> <span class="hl-attribute">id</span>=<span class="hl-value">"errorChannel"</span>&gt;
     &lt;<span class="hl-tag">queue</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"500"</span>/&gt;
 &lt;<span class="hl-tag">/channel</span>&gt;</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        The default "errorChannel" is a PublishSubscribeChannel.
      </td></tr></tbody></table></div><p>
    </p><p>
      The most important thing to understand here is that the messaging-based error handling will only apply
      to Exceptions that are thrown by a Spring Integration task that is executing within a TaskExecutor.
      This does <span class="emphasis"><em>not</em></span> apply to Exceptions thrown by a handler that is operating within
      the same thread as the sender (e.g. through a DirectChannel as described above).
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      When Exceptions occur in a scheduled poller task's execution, those exceptions will be wrapped in
      <code class="classname">ErrorMessages</code> and sent to the 'errorChannel' as well.
    </td></tr></tbody></table></div><p>
      To enable global error handling, simply register a handler on that channel. For example, you can configure
      Spring Integration's <code class="classname">ErrorMessageExceptionTypeRouter</code> as the handler of an endpoint
      that is subscribed to the 'errorChannel'. That router can then spread the error messages across multiple
      channels based on <code class="classname">Exception</code> type.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="annotations"></a>B.5&nbsp;Annotation Support</h2></div></div></div><p>
      In addition to the XML namespace support for configuring Message Endpoints, it is also possible to use
      annotations. First, Spring Integration provides the class-level <code class="interfacename">@MessageEndpoint</code>
      as a <span class="emphasis"><em>stereotype</em></span> annotation meaning that is itself annotated with Spring's @Component
      annotation and therefore is recognized automatically as a bean definition when using Spring component-scanning.
    </p><p>
      Even more importantly are the various Method-level annotations that indicate the annotated method is capable of
      handling a message. The following example demonstrates both:
      </p><pre class="programlisting">@MessageEndpoint
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FooService {

    @ServiceActivator
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processMessage(Message message) {
        ...
    }
}</pre><p>
    </p><p>
      Exactly what it means for the method to "handle" the Message depends on the particular annotation. The following
      are available with Spring Integration, and the behavior of each is described in its own chapter or section within
      this reference: @Transformer, @Router, @Splitter, @Aggregator, @ServiceActivator, and @ChannelAdapter.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
      The @MessageEndpoint is not required if using XML configuration in combination with annotations. If you want to
      configure a POJO reference from the "ref" attribute of a &lt;service-activator/&gt; element, it is sufficient to
      provide the method-level annotations. In that case, the annotation prevents ambiguity even when no "method"
      attribute exists on the &lt;service-activator/&gt; element.
    </td></tr></tbody></table></div><p>
      In most cases, the annotated handler method should not require the <code class="classname">Message</code> type as its
      parameter. Instead, the method parameter type can match the message's payload type.
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FooService {

    @Handler
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar(Foo foo) {
        ...
    }

}</pre><p>
    </p><p>
      When the method parameter should be mapped from a value in the <code class="classname">MessageHeaders</code>, another
      option is to use the parameter-level <code class="interfacename">@Header</code> annotation. In general, methods
      annotated with the Spring Integration annotations can either accept the <code class="classname">Message</code> itself, the
      message payload, or a header value (with @Header) as the parameter. In fact, the method can accept a combination,
      such as:
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FooService {

    @ServiceActivator
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar(String payload, @Header(<span class="hl-string">"x"</span>) <span class="hl-keyword">int</span> valueX, @Header(<span class="hl-string">"y"</span>) <span class="hl-keyword">int</span> valueY) {
        ...
    }

}</pre><p>
      There is also a @Headers annotation that provides all of the Message headers as a Map:
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FooService {

    @ServiceActivator
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar(String payload, @Headers Map&lt;String, Object&gt; headerMap) {
        ...
    }

}</pre><p>
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
        A Map-typed argument does not strictly require the use of the @Headers annotation. In other words
        the following is also valid: <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar(String payload, Map&lt;String, Object&gt; headerMap)</pre>
        However this can lead to unresolvable ambiguities if the payload is itself a Map. For that reason, we
        highly recommend using the annotation whenever expecting the headers. For a much more detailed
        description, see the javadoc for <code class="classname">MethodParameterMessageMapper</code>.
      </td></tr></tbody></table></div><p>
    </p><p>
      For several of these annotations, when a Message-handling method returns a non-null value, the endpoint will
      attempt to send a reply. This is consistent across both configuration options (namespace and annotations) in
      that such an endpoint's output channel will be used if available, and the REPLY_CHANNEL message header value
      will be used as a fallback.
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Integration Reference Manual_files/tip.gif"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
      The combination of output channels on endpoints and the reply channel message header enables a pipeline approach
      where multiple components have an output channel, and the final component simply allows the reply message to be
      forwarded to the reply channel as specified in the original request message. In other words, the final component
      depends on the information provided by the original sender and can dynamically support any number of clients as a
      result. This is an example of <a class="ulink" href="http://eaipatterns.com/ReturnAddress.html" target="_top">Return Address</a>.
	</td></tr></tbody></table></div><p>
      In addition to the examples shown here, these annotations also support inputChannel and outputChannel properties.
      </p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FooService {

    @ServiceActivator(inputChannel=<span class="hl-string">"input"</span>, outputChannel=<span class="hl-string">"output"</span>)
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> bar(String payload, @Headers Map&lt;String, Object&gt; headerMap) {
        ...
    }

}</pre><p>
      That provides a pure annotation-driven alternative to the XML configuration. However, it is generally recommended
      to use XML for the endpoints, since it is easier to keep track of the overall configuration in a single, external
      location (and besides the namespace-based XML configuration is not very verbose). If you do prefer to provide
      channels with the annotations however, you just need to enable a BeanPostProcessor. The following element should
      be added: </p><pre class="programlisting"> &lt;<span class="hl-tag">annotation-config</span>/&gt; </pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Integration Reference Manual_files/note.gif"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        When configuring the "inputChannel" and "outputChannel" with annotations, the "inputChannel"
        <span class="emphasis"><em>must</em></span> be a reference to a <code class="interfacename">SubscribableChannel</code> instance.
        Otherwise, it would be necessary to also provide the full poller configuration via annotations, and those
        settings (e.g. the trigger for scheduling the poller) should be externalized rather than hard-coded within
        an annotation. If the input channel that you want to receive Messages from is indeed a 
        <code class="interfacename">PollableChannel</code> instance, one option to consider is the Messaging Bridge.
        Spring Integration's "bridge" element can be used to connect a PollableChannel directly to a
        SubscribableChannel. Then, the polling metadata is externally configured, but the annotation option is
        still available. For more detail see <a class="xref" href="http://static.springsource.org/spring-integration/reference/htmlsingle/spring-integration-reference.html#bridge" title="15.Â Messaging Bridge">Chapter&nbsp;15, <i>Messaging Bridge</i></a>.
      </td></tr></tbody></table></div><p>
    </p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="resources"></a>Appendix&nbsp;C.&nbsp;Additional Resources</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resources-home"></a>C.1&nbsp;Spring Integration Home</h2></div></div></div><p>
      The definitive source of information about Spring Integration is the
      <a class="ulink" href="http://www.springsource.org/spring-integration" target="_top">Spring Integration Home</a> at
      <a class="ulink" href="http://www.springsource.org/" target="_top">http://www.springsource.org</a>. That site serves as a hub of
      information and is the best place to find up-to-date announcements about the project as well as links to
      articles, blogs, and new sample applications.
    </p></div></div></div><!--Begin LoopFuse code--><script src="./Spring Integration Reference Manual_files/listen.js" type="text/javascript"></script><script type="text/javascript" src="./Spring Integration Reference Manual_files/chimera.js"></script><script type="text/javascript">
			_lf_cid = "LF_48be82fa";
			_lf_remora();
		</script><!--End LoopFuse code--><!-- Begin 2nd Google code - a mod -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script src="./Spring Integration Reference Manual_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">
var OrgTracker = _gat._getTracker("UA-2728886-2"); OrgTracker._setDomainName("none");
OrgTracker._setAllowLinker(true);
OrgTracker._trackPageview();
</script>
 <!-- End 2nd Google code -->


<script type="text/javascript">

function detectLastFrame() {
   var thisF = this.window;
   var allF = parent.top.frames;
   return allF[allF.length - 1] == thisF; }

// Only inject the following code if this is a normal page or the last // frame of a frameset.
if (parent.top.frames.length == 0 || detectLastFrame()) {
    // Inject the SpringSource search widget too.
    document.write(unescape("%3Cscript src='http://search.springsource.org/widget/searchtool.js' type='text/javascript'%3E%3C/script%3E"));
}
</script><script src="./Spring Integration Reference Manual_files/searchtool.js" type="text/javascript"></script>

<div id="bodyEmptyFiller">&nbsp;</div><div id="searchBar">     <div id="logoSpan"><a target="_new" href="http://www.springsource.com/?cid=70170000000XBq5"><img border="0" src="./Spring Integration Reference Manual_files/Logo_SpringSource_SearchBar.png"></a></div>      <div id="searchFields">        <input name="searchKeys" type="text" id="searchKeys" value="Search Documentation" style="color: rgb(204, 204, 204); ">        <select name="searchWhat" id="searchWhat"><option value="all">all</option><option value="SpringSource">SpringSource</option><option value="Grails">Grails</option><option value="Hyperic">Hyperic</option><option value="Gemstone">Gemstone</option><option value="RabbitMQ">RabbitMQ</option></select>        <img title="Search Documentation" src="./Spring Integration Reference Manual_files/Btn_Search.png" id="searchLens">      </div>      <div id="adArrow"><img title="click to toggle" src="./Spring Integration Reference Manual_files/ArrowUp_Ads.png" id="arrowImg"></div>      <div id="daAd" style="display: none; "><a target="_new" href="http://www.springsource.com/products/springsource-tool-suite-download?cid=70170000000XBq5"><img border="0" src="./Spring Integration Reference Manual_files/Ads_STSDownload.png"></a></div>      <div id="resultsDiv"></div></div></body></html>